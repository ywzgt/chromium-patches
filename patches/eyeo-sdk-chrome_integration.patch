From ed6b68a4c136baeaa6290ddeba87bc8be452b7c7 Mon Sep 17 00:00:00 2001
From: chromium-sdk <project_26591639_bot@noreply.gitlab.com>
Date: Thu, 30 May 2024 07:40:07 +0200
Subject: [PATCH] eyeo Browser Ad filtering Solution: Chrome Integration Module

Based on Chromium 126.0.6478.8

Pre-requisites: eyeo Browser Ad filtering Solution: Base Module
---
 chrome/app/chrome_main_delegate.cc            |   7 +-
 chrome/browser/BUILD.gn                       |  10 +
 chrome/browser/about_flags.cc                 |   9 +
 chrome/browser/adblock/README.md              |   3 +
 .../adblock_chrome_content_browser_client.cc  |  28 +
 .../adblock_chrome_content_browser_client.h   |  31 +
 ..._chrome_content_browser_client_unittest.cc | 203 +++++
 chrome/browser/adblock/android/BUILD.gn       |  77 ++
 .../adblock/AdblockControllerTest.java        |  52 ++
 .../adblock/AdblockPopupInfoBarTest.java      | 123 +++
 .../adblock/AdblockPopupMessageTest.java      | 107 +++
 .../browser/adblock/CheckChromeFlagsTest.java |  65 ++
 .../browser/adblock/DefaultSettingsTest.java  |  54 ++
 .../adblock/FilteringConfigurationTest.java   |  77 ++
 .../ResourceClassificationNotifierTest.java   | 151 ++++
 .../adblock/TestPagesCircumventionTest.java   |  52 ++
 .../browser/adblock/TestPagesCspTest.java     |  52 ++
 .../adblock/TestPagesElemhideEmuInvTest.java  |  49 ++
 .../adblock/TestPagesElemhideEmuTest.java     |  49 ++
 .../adblock/TestPagesElemhideTest.java        |  49 ++
 .../adblock/TestPagesExceptionTest.java       | 108 +++
 .../browser/adblock/TestPagesFilterTest.java  | 107 +++
 .../adblock/TestPagesHeaderFilterTest.java    |  52 ++
 .../browser/adblock/TestPagesHelper.java      | 144 ++++
 .../adblock/TestPagesInlineCssTest.java       |  49 ++
 .../browser/adblock/TestPagesRemoveTest.java  |  49 ++
 .../browser/adblock/TestPagesRewriteTest.java |  52 ++
 .../browser/adblock/TestPagesSiteKeyTest.java |  52 ++
 .../adblock/TestPagesSnippetsTest.java        |  52 ++
 .../adblock/TestPagesWebsocketTest.java       |  52 ++
 .../adblock/TestPagesWildcardDomainTest.java  |  52 ++
 .../adblock_acceptable_ads_browsertest.cc     | 279 +++++++
 ...rome_content_browser_client_browsertest.cc | 126 +++
 .../adblock_content_filters_browsertest.cc    | 326 ++++++++
 .../test/adblock_debug_url_browsertest.cc     | 318 ++++++++
 .../test/adblock_filter_list_browsertest.cc   | 401 ++++++++++
 ...ck_filtering_configurations_browsertest.cc | 720 ++++++++++++++++++
 ...ock_frame_hierarchy_builder_browsertest.cc | 475 ++++++++++++
 .../adblock/test/adblock_ml_browsertest.cc    |  77 ++
 .../test/adblock_multiple_tabs_browsertest.cc | 168 ++++
 .../test/adblock_non_ascii_browsertest.cc     |  78 ++
 .../adblock/test/adblock_popup_browsertest.cc | 462 +++++++++++
 .../adblock_service_workers_browsertest.cc    | 157 ++++
 .../test/adblock_snippets_browsertest.cc      |  80 ++
 ...dblock_subscription_service_browsertest.cc | 226 ++++++
 .../adblock_telemetry_service_browsertest.cc  | 294 +++++++
 .../adblock_trusted_events_browsertest.cc     | 138 ++++
 .../test/adblock_web_bundle_browsertest.cc    | 427 +++++++++++
 chrome/browser/browser_resources.grd          |   6 +
 chrome/browser/chrome_browser_main.cc         |   7 +
 .../client_hints/client_hints_browsertest.cc  |  11 +-
 chrome/browser/extensions/BUILD.gn            |   5 +
 .../allowlist.cc                              |   6 +
 chrome/browser/extensions/component_loader.cc |  10 +
 chrome/browser/flag-metadata.json             |   8 +
 chrome/browser/flag-never-expire-list.json    |   4 +
 chrome/browser/flag_descriptions.cc           |   8 +
 chrome/browser/flag_descriptions.h            |   7 +
 chrome/browser/net/errorpage_browsertest.cc   |   8 +
 ..._page_load_metrics_observer_browsertest.cc |   7 +-
 chrome/browser/preferences/BUILD.gn           |   4 +
 .../prefs/chrome_pref_service_factory.cc      |  11 +
 ...hrome_browser_main_extra_parts_profiles.cc |  21 +
 .../profile_keyed_service_browsertest.cc      |  24 +-
 chrome/browser/resources/BUILD.gn             |   5 +
 .../browser/resources/adblock_ml/.gitignore   |   1 +
 .../resources/adblock_ml/manifest.json        |  38 +
 .../browser/resources/adblock_ml/service.js   |  20 +
 .../component_extension_resources.grd         |   7 +
 .../safe_browsing_blocking_page_test.cc       |   7 +-
 ...subresource_filter_browser_test_harness.cc |   8 +-
 chrome/browser/ui/BUILD.gn                    |   5 +
 chrome/browser/ui/prefs/pref_watcher.cc       |  13 +
 chrome/browser/ui/tab_helpers.cc              |  22 +
 .../webui/chrome_web_ui_controller_factory.cc |   1 +
 chrome/chrome_paks.gni                        |   5 +
 chrome/common/BUILD.gn                        |   3 +
 .../common/extensions/extension_constants.cc  |   5 +
 .../common/extensions/extension_constants.h   |   7 +
 chrome/test/BUILD.gn                          |  33 +-
 chrome/test/base/chrome_test_launcher.cc      |   7 +-
 chrome/test/base/in_process_browser_test.cc   |  24 +-
 82 files changed, 7118 insertions(+), 9 deletions(-)
 create mode 100644 chrome/browser/adblock/README.md
 create mode 100644 chrome/browser/adblock/adblock_chrome_content_browser_client.cc
 create mode 100644 chrome/browser/adblock/adblock_chrome_content_browser_client.h
 create mode 100644 chrome/browser/adblock/adblock_chrome_content_browser_client_unittest.cc
 create mode 100644 chrome/browser/adblock/android/BUILD.gn
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/AdblockControllerTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/AdblockPopupInfoBarTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/AdblockPopupMessageTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/CheckChromeFlagsTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/DefaultSettingsTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/FilteringConfigurationTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/ResourceClassificationNotifierTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesCircumventionTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesCspTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideEmuInvTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideEmuTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesExceptionTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesFilterTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesHeaderFilterTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesHelper.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesInlineCssTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesRemoveTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesRewriteTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesSiteKeyTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesSnippetsTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesWebsocketTest.java
 create mode 100644 chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesWildcardDomainTest.java
 create mode 100644 chrome/browser/adblock/test/adblock_acceptable_ads_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_chrome_content_browser_client_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_content_filters_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_debug_url_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_filter_list_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_filtering_configurations_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_frame_hierarchy_builder_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_ml_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_multiple_tabs_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_non_ascii_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_popup_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_service_workers_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_snippets_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_subscription_service_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_telemetry_service_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_trusted_events_browsertest.cc
 create mode 100644 chrome/browser/adblock/test/adblock_web_bundle_browsertest.cc
 create mode 100644 chrome/browser/resources/adblock_ml/.gitignore
 create mode 100644 chrome/browser/resources/adblock_ml/manifest.json
 create mode 100644 chrome/browser/resources/adblock_ml/service.js

diff --git a/chrome/app/chrome_main_delegate.cc b/chrome/app/chrome_main_delegate.cc
index d60a195d58..ffd8406f21 100644
--- a/chrome/app/chrome_main_delegate.cc
+++ b/chrome/app/chrome_main_delegate.cc
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/app/chrome_main_delegate.h"
 
@@ -37,6 +41,7 @@
 #include "base/trace_event/trace_event_impl.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
+#include "chrome/browser/adblock/adblock_chrome_content_browser_client.h"
 #include "chrome/browser/buildflags.h"
 #include "chrome/browser/chrome_content_browser_client.h"
 #include "chrome/browser/chrome_resource_bundle_helper.h"
@@ -1903,7 +1908,7 @@ content::ContentClient* ChromeMainDelegate::CreateContentClient() {
 content::ContentBrowserClient*
 ChromeMainDelegate::CreateContentBrowserClient() {
   chrome_content_browser_client_ =
-      std::make_unique<ChromeContentBrowserClient>();
+      std::make_unique<AdblockChromeContentBrowserClient>();
   return chrome_content_browser_client_.get();
 }
 
diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index aa9bd9c38d..3cb5eb7c78 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2014 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//base/allocator/allocator.gni")
 import("//build/buildflag_header.gni")
@@ -155,6 +158,8 @@ static_library("browser") {
     "accessibility/page_colors_factory.h",
     "accessibility/prefers_default_scrollbar_styles_prefs.cc",
     "accessibility/prefers_default_scrollbar_styles_prefs.h",
+    "adblock/adblock_chrome_content_browser_client.cc",
+    "adblock/adblock_chrome_content_browser_client.h",
     "affiliations/affiliation_service_factory.cc",
     "affiliations/affiliation_service_factory.h",
     "after_startup_task_utils.cc",
@@ -2049,6 +2054,7 @@ static_library("browser") {
     "//chrome/common:constants",
     "//chrome/services/file_util/public/mojom",
     "//components/account_id",
+    "//components/adblock/content:browser",
     "//components/autofill/core/browser",
     "//components/commerce/core/product_specifications:product_specifications",
     "//components/cross_device/logging",
@@ -2192,6 +2198,8 @@ static_library("browser") {
     "//chrome/installer/util:with_no_strings",
     "//chrome/services/on_device_translation:on_device_translation_service",
     "//chrome/services/speech/buildflags",
+    "//components/adblock/content:browser",
+    "//components/adblock/core/converter",
     "//components/assist_ranker",
     "//components/autofill/content/browser",
     "//components/autofill/content/common:features",
@@ -3523,6 +3531,8 @@ static_library("browser") {
       "webauthn/android/webauthn_request_delegate_android.cc",
       "webauthn/android/webauthn_request_delegate_android.h",
     ]
+
+
     public_deps += [
       "//chrome/android/features/dev_ui:buildflags",
       "//components/image_fetcher/core",
diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
index ea4f31da9c..b4fb56fd35 100644
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 // Instructions for adding new entries to this file:
 // https://chromium.googlesource.com/chromium/src/+/main/docs/how_to_add_your_feature_flag.md#step-2_adding-the-feature-flag-to-the-chrome_flags-ui
@@ -69,6 +73,7 @@
 #include "chrome/common/chrome_features.h"
 #include "chrome/common/chrome_switches.h"
 #include "chrome/common/companion/visual_query/features.h"
+#include "components/adblock/core/features.h"
 #include "components/assist_ranker/predictor_config_definitions.h"
 #include "components/autofill/content/common/content_autofill_features.h"
 #include "components/autofill/core/browser/autofill_experiments.h"
@@ -10862,6 +10867,10 @@ const FeatureEntry kFeatureEntries[] = {
      FEATURE_VALUE_TYPE(
          content_settings::features::kContentSettingsPartitioning)},
 
+    {"eyeo-ml-service", flag_descriptions::kEyeoMlServiceName,
+     flag_descriptions::kEyeoMlServiceDescription, kOsDesktop,
+     FEATURE_VALUE_TYPE(adblock::kEyeoMlServiceFeature)},
+
 #if BUILDFLAG(IS_ANDROID)
     {"enable-vertical-automotive-back-button-toolbar",
      flag_descriptions::kVerticalAutomotiveBackButtonToolbarName,
diff --git a/chrome/browser/adblock/README.md b/chrome/browser/adblock/README.md
new file mode 100644
index 0000000000..d096ec3e2d
--- /dev/null
+++ b/chrome/browser/adblock/README.md
@@ -0,0 +1,3 @@
+This folder contains the OS-agnostic, Chrome-specific source code of eyeo Chromium SDK.
+
+For the full documentation, refer to [components/adblock](/components/adblock).
diff --git a/chrome/browser/adblock/adblock_chrome_content_browser_client.cc b/chrome/browser/adblock/adblock_chrome_content_browser_client.cc
new file mode 100644
index 0000000000..cae70ff9de
--- /dev/null
+++ b/chrome/browser/adblock/adblock_chrome_content_browser_client.cc
@@ -0,0 +1,28 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "chrome/browser/adblock/adblock_chrome_content_browser_client.h"
+
+#include "chrome/browser/profiles/profile.h"
+
+content::BrowserContext* AdblockChromeContentBrowserClient::GetBrowserContext(
+    content::RenderFrameHost* frame) {
+  return frame ? Profile::FromBrowserContext(
+                     frame->GetProcess()->GetBrowserContext())
+                     ->GetOriginalProfile()
+               : nullptr;
+}
diff --git a/chrome/browser/adblock/adblock_chrome_content_browser_client.h b/chrome/browser/adblock/adblock_chrome_content_browser_client.h
new file mode 100644
index 0000000000..97a738cc16
--- /dev/null
+++ b/chrome/browser/adblock/adblock_chrome_content_browser_client.h
@@ -0,0 +1,31 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef CHROME_BROWSER_ADBLOCK_ADBLOCK_CHROME_CONTENT_BROWSER_CLIENT_H_
+#define CHROME_BROWSER_ADBLOCK_ADBLOCK_CHROME_CONTENT_BROWSER_CLIENT_H_
+
+#include "chrome/browser/chrome_content_browser_client.h"
+#include "components/adblock/content/browser/adblock_content_browser_client.h"
+
+class AdblockChromeContentBrowserClient
+    : public adblock::AdblockContentBrowserClient<ChromeContentBrowserClient> {
+ private:
+  content::BrowserContext* GetBrowserContext(
+      content::RenderFrameHost* frame) override;
+};
+
+#endif  // CHROME_BROWSER_ADBLOCK_ADBLOCK_CHROME_CONTENT_BROWSER_CLIENT_H_
diff --git a/chrome/browser/adblock/adblock_chrome_content_browser_client_unittest.cc b/chrome/browser/adblock/adblock_chrome_content_browser_client_unittest.cc
new file mode 100644
index 0000000000..fc9f153ca4
--- /dev/null
+++ b/chrome/browser/adblock/adblock_chrome_content_browser_client_unittest.cc
@@ -0,0 +1,203 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "chrome/browser/adblock/adblock_chrome_content_browser_client.h"
+
+#include "base/callback_list.h"
+#include "base/memory/raw_ptr.h"
+#include "base/run_loop.h"
+#include "base/test/gmock_move_support.h"
+#include "base/test/mock_callback.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/test/base/chrome_render_view_host_test_harness.h"
+#include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/test/mock_resource_classification_runner.h"
+#include "components/adblock/core/common/adblock_prefs.h"
+#include "components/adblock/core/common/content_type.h"
+#include "components/adblock/core/subscription/installed_subscription.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "components/adblock/core/subscription/test/mock_subscription_collection.h"
+#include "components/adblock/core/subscription/test/mock_subscription_service.h"
+#include "components/keyed_service/core/keyed_service.h"
+#include "content/public/browser/content_browser_client.h"
+#include "content/public/test/mock_render_process_host.h"
+#include "content/public/test/test_renderer_host.h"
+#include "gmock/gmock.h"
+#include "services/network/public/mojom/network_context.mojom.h"
+#include "services/network/public/mojom/websocket.mojom.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+using testing::_;
+using testing::Ref;
+using testing::Return;
+
+namespace adblock {
+
+class AdblockChromeContentBrowserClientUnitTest
+    : public ChromeRenderViewHostTestHarness {
+ public:
+  TestingProfile::TestingFactories GetTestingFactories() const override {
+    return {
+        {SubscriptionServiceFactory::GetInstance(),
+         base::BindRepeating(
+             [](content::BrowserContext* bc) -> std::unique_ptr<KeyedService> {
+               return std::make_unique<MockSubscriptionService>();
+             })},
+        {ResourceClassificationRunnerFactory::GetInstance(),
+         base::BindRepeating(
+             [](content::BrowserContext* bc) -> std::unique_ptr<KeyedService> {
+               return std::make_unique<MockResourceClassificationRunner>();
+             })}};
+  }
+
+  void SetUp() override {
+    ChromeRenderViewHostTestHarness::SetUp();
+
+    subscription_service_ = static_cast<MockSubscriptionService*>(
+        SubscriptionServiceFactory::GetForBrowserContext(profile()));
+    resource_classification_runner_ =
+        static_cast<MockResourceClassificationRunner*>(
+            ResourceClassificationRunnerFactory::GetForBrowserContext(
+                profile()));
+  }
+
+  void TearDown() override {
+    subscription_service_ = nullptr;
+    resource_classification_runner_ = nullptr;
+    ChromeRenderViewHostTestHarness::TearDown();
+  }
+
+  raw_ptr<MockSubscriptionService> subscription_service_;
+  raw_ptr<MockResourceClassificationRunner> resource_classification_runner_;
+};
+
+TEST_F(AdblockChromeContentBrowserClientUnitTest,
+       WillInterceptWebSocketWhenFilteringEnabled) {
+  AdblockChromeContentBrowserClient content_client;
+  subscription_service_->WillRequireFiltering(true);
+  EXPECT_TRUE(content_client.WillInterceptWebSocket(main_rfh()));
+}
+
+TEST_F(AdblockChromeContentBrowserClientUnitTest,
+       WillNotInterceptWebSocketWhenFilteringDisabled) {
+  AdblockChromeContentBrowserClient content_client;
+  subscription_service_->WillRequireFiltering(false);
+  EXPECT_FALSE(content_client.WillInterceptWebSocket(main_rfh()));
+}
+
+TEST_F(AdblockChromeContentBrowserClientUnitTest,
+       RenderFrameHostDiesBeforeClassificationFinished) {
+  const auto kSocketUrl = GURL("wss://domain.com/test");
+  subscription_service_->WillRequireFiltering(true);
+  EXPECT_CALL(*subscription_service_, GetCurrentSnapshot()).WillOnce([]() {
+    SubscriptionService::Snapshot snapshot;
+    snapshot.push_back(std::make_unique<MockSubscriptionCollection>());
+    return snapshot;
+  });
+  CheckFilterMatchCallback classification_callback;
+  EXPECT_CALL(*resource_classification_runner_,
+              CheckRequestFilterMatch(_, kSocketUrl, ContentType::Websocket,
+                                      Ref(*main_rfh()), _))
+      .WillOnce(MoveArg<4>(&classification_callback));
+
+  AdblockChromeContentBrowserClient content_client;
+  base::MockCallback<content::ContentBrowserClient::WebSocketFactory>
+      web_socket_factory;
+  // The web_socket_factory callback will never be called because the
+  // associated RenderFrameHost will be dead.
+  EXPECT_CALL(web_socket_factory, Run(_, _, _, _, _)).Times(0);
+
+  const net::SiteForCookies site_for_cookies;
+  content_client.CreateWebSocket(main_rfh(), web_socket_factory.Get(),
+                                 kSocketUrl, site_for_cookies, absl::nullopt,
+                                 {});
+  // Tab is closed.
+  DeleteContents();
+
+  // Classification finishes now. It will not trigger a call to
+  // |web_socket_factory| because the RFH is dead.
+  std::move(classification_callback).Run(FilterMatchResult::kBlockRule);
+
+  task_environment()->RunUntilIdle();
+}
+
+TEST_F(AdblockChromeContentBrowserClientUnitTest, WebSocketAllowed) {
+  subscription_service_->WillRequireFiltering(true);
+  const auto kSocketUrl = GURL("wss://domain.com/test");
+  EXPECT_CALL(*subscription_service_, GetCurrentSnapshot()).WillOnce([]() {
+    SubscriptionService::Snapshot snapshot;
+    snapshot.push_back(std::make_unique<MockSubscriptionCollection>());
+    return snapshot;
+  });
+  CheckFilterMatchCallback classification_callback;
+  EXPECT_CALL(*resource_classification_runner_,
+              CheckRequestFilterMatch(_, kSocketUrl, ContentType::Websocket,
+                                      Ref(*main_rfh()), _))
+      .WillOnce(MoveArg<4>(&classification_callback));
+
+  AdblockChromeContentBrowserClient content_client;
+  base::MockCallback<content::ContentBrowserClient::WebSocketFactory>
+      web_socket_factory;
+  // The web_socket_factory callback will be called to let the web socket
+  // continue connecting.
+  EXPECT_CALL(web_socket_factory, Run(kSocketUrl, _, _, _, _));
+
+  const net::SiteForCookies site_for_cookies;
+  content_client.CreateWebSocket(main_rfh(), web_socket_factory.Get(),
+                                 kSocketUrl, site_for_cookies, absl::nullopt,
+                                 {});
+
+  // Classification finishes now. It will trigger a call to |web_socket_factory|
+  std::move(classification_callback).Run(FilterMatchResult::kAllowRule);
+
+  task_environment()->RunUntilIdle();
+}
+
+TEST_F(AdblockChromeContentBrowserClientUnitTest, WebSocketBlocked) {
+  subscription_service_->WillRequireFiltering(true);
+  const auto kSocketUrl = GURL("wss://domain.com/test");
+  EXPECT_CALL(*subscription_service_, GetCurrentSnapshot()).WillOnce([]() {
+    SubscriptionService::Snapshot snapshot;
+    snapshot.push_back(std::make_unique<MockSubscriptionCollection>());
+    return snapshot;
+  });
+  CheckFilterMatchCallback classification_callback;
+  EXPECT_CALL(*resource_classification_runner_,
+              CheckRequestFilterMatch(_, kSocketUrl, ContentType::Websocket,
+                                      Ref(*main_rfh()), _))
+      .WillOnce(MoveArg<4>(&classification_callback));
+
+  AdblockChromeContentBrowserClient content_client;
+  base::MockCallback<content::ContentBrowserClient::WebSocketFactory>
+      web_socket_factory;
+  // The web_socket_factory callback will not be called as to disallow
+  // connection.
+  EXPECT_CALL(web_socket_factory, Run(kSocketUrl, _, _, _, _)).Times(0);
+
+  const net::SiteForCookies site_for_cookies;
+  content_client.CreateWebSocket(main_rfh(), web_socket_factory.Get(),
+                                 kSocketUrl, site_for_cookies, absl::nullopt,
+                                 {});
+
+  // Classification finishes now.
+  std::move(classification_callback).Run(FilterMatchResult::kBlockRule);
+
+  task_environment()->RunUntilIdle();
+}
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/android/BUILD.gn b/chrome/browser/adblock/android/BUILD.gn
new file mode 100644
index 0000000000..d44d630e28
--- /dev/null
+++ b/chrome/browser/adblock/android/BUILD.gn
@@ -0,0 +1,77 @@
+# This file is part of eyeo Chromium SDK,
+# Copyright (C) 2006-present eyeo GmbH
+# eyeo Chromium SDK is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 3 as
+# published by the Free Software Foundation.
+# eyeo Chromium SDK is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# You should have received a copy of the GNU General Public License
+# along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+import("//build/config/android/rules.gni")
+import("//build/config/locales.gni")
+import("//third_party/jni_zero/jni_zero.gni")
+import("//tools/grit/grit_rule.gni")
+
+android_library("adblock_java_tests") {
+  testonly = true
+
+  sources = [
+    "javatests/src/org/chromium/chrome/browser/adblock/AdblockControllerTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/CheckChromeFlagsTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/DefaultSettingsTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/FilteringConfigurationTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/ResourceClassificationNotifierTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesCircumventionTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesCspTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideEmuInvTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideEmuTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesExceptionTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesFilterTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesHeaderFilterTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesHelper.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesInlineCssTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesRemoveTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesRewriteTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesSiteKeyTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesSnippetsTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesWebsocketTest.java",
+    "javatests/src/org/chromium/chrome/browser/adblock/TestPagesWildcardDomainTest.java",
+  ]
+
+
+  deps = [
+    "//base:base_java",
+    "//base:base_java_test_support",
+    "//chrome/android:chrome_java",
+    "//chrome/browser/flags:java",
+    "//chrome/browser/profiles/android:java",
+    "//chrome/browser/settings:test_support_java",
+    "//chrome/browser/tab:java",
+    "//chrome/browser/tabmodel:java",
+    "//chrome/test/android:chrome_java_integration_test_support",
+    "//chrome/test/android:chrome_java_test_support_common",
+    "//components/adblock/android:adblock_controller_java",
+    "//components/adblock/android:adblock_java_tests_base",
+    "//components/infobars/android:java",
+    "//components/infobars/core:infobar_enums_java",
+    "//components/messages/android/test:test_support_java",
+    "//content/public/android:content_full_java",
+    "//content/public/android:content_main_dex_java",
+    "//content/public/test/android:content_java_test_support",
+    "//net/android:net_java_test_support",
+    "//third_party/androidx:androidx_fragment_fragment_java",
+    "//third_party/androidx:androidx_test_monitor_java",
+    "//third_party/androidx:androidx_test_runner_java",
+    "//third_party/hamcrest:hamcrest_core_java",
+    "//third_party/hamcrest:hamcrest_library_java",
+    "//third_party/junit:junit",
+    "//ui/android:ui_no_recycler_view_java",
+    "//url:gurl_java",
+  ]
+
+}
+
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/AdblockControllerTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/AdblockControllerTest.java
new file mode 100644
index 0000000000..352457790e
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/AdblockControllerTest.java
@@ -0,0 +1,52 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.AdblockController;
+import org.chromium.components.adblock.AdblockControllerTestBase;
+import org.chromium.content_public.browser.test.util.TestThreadUtils;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class AdblockControllerTest extends AdblockControllerTestBase {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    @Before
+    public void setUp() {
+        mActivityTestRule.startMainActivityOnBlankPage();
+        TestThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    mAdblockController =
+                            AdblockController.getInstance(
+                                    ProfileManager.getLastUsedRegularProfile());
+                });
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/AdblockPopupInfoBarTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/AdblockPopupInfoBarTest.java
new file mode 100644
index 0000000000..f7609903b8
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/AdblockPopupInfoBarTest.java
@@ -0,0 +1,123 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import androidx.test.InstrumentationRegistry;
+import androidx.test.filters.MediumTest;
+
+import org.hamcrest.Matchers;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.task.PostTask;
+import org.chromium.base.task.TaskTraits;
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.base.test.util.Criteria;
+import org.chromium.base.test.util.CriteriaHelper;
+import org.chromium.base.test.util.Feature;
+import org.chromium.base.test.util.Features.DisableFeatures;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.browser.infobar.InfoBarIdentifier;
+import org.chromium.chrome.browser.tabmodel.TabModelSelector;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.infobars.InfoBar;
+import org.chromium.net.test.EmbeddedTestServer;
+
+// NOTE: Messages feature had to be disabled when testing infobars
+// https://gitlab.com/eyeo/adblockplus/abpchromium/-/commit/a617caaa5692630f73d967a55d86bf52cc491ad5
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+@DisableFeatures("MessagesForAndroidPopupBlocked")
+public class AdblockPopupInfoBarTest {
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private static final String POPUP_HTML_PATH = "/chrome/test/data/android/popup_test.html";
+
+    private String mPopupHtmlUrl;
+    private EmbeddedTestServer mTestServer;
+
+    @Before
+    public void setUp() throws Exception {
+        // Create a new temporary instance to ensure the Class is loaded. Otherwise we will get a
+        // ClassNotFoundException when trying to instantiate during startup.
+        mActivityTestRule.startMainActivityOnBlankPage();
+
+        PostTask.runOrPostTask(
+                TaskTraits.UI_DEFAULT, () -> Assert.assertEquals(0, getNumInfobarsShowing()));
+
+        mTestServer = EmbeddedTestServer.createAndStartServer(InstrumentationRegistry.getContext());
+        mPopupHtmlUrl = mTestServer.getURL(POPUP_HTML_PATH);
+    }
+
+    @After
+    public void tearDown() {
+        mTestServer.stopAndDestroyServer();
+    }
+
+    private int getNumInfobarsShowing() {
+        return mActivityTestRule.getInfoBars().size();
+    }
+
+    public int getTabCount() {
+        final TabModelSelector tabModelSelector =
+                mActivityTestRule.getActivity().getTabModelSelectorSupplier().get();
+        Assert.assertNotNull(tabModelSelector);
+        return tabModelSelector.getTotalTabCount();
+    }
+
+    @Test
+    @MediumTest
+    @Feature({"adblock"})
+    public void popUpBlockedInfoBarVisibleWhenAbpEnabled() throws InterruptedException {
+        mActivityTestRule.loadUrl(mPopupHtmlUrl);
+        Assert.assertEquals(1, getTabCount());
+        CriteriaHelper.pollUiThread(
+                () -> {
+                    Criteria.checkThat(getNumInfobarsShowing(), Matchers.is(1));
+                    InfoBar frontInfoBar = mActivityTestRule.getInfoBars().get(0);
+                    Criteria.checkThat(
+                            "Invalid infobar type shown",
+                            frontInfoBar.getInfoBarIdentifier(),
+                            Matchers.is(InfoBarIdentifier.POPUP_BLOCKED_INFOBAR_DELEGATE_MOBILE));
+                });
+    }
+
+    @Test
+    @MediumTest
+    @CommandLineFlags.Add({"disable-adblock"})
+    @Feature({"adblock"})
+    public void popUpBlockedInfoBarVisibleWhenAbpDisabled() {
+        mActivityTestRule.loadUrl(mPopupHtmlUrl);
+        Assert.assertEquals(1, getTabCount());
+        CriteriaHelper.pollUiThread(
+                () -> {
+                    Criteria.checkThat(getNumInfobarsShowing(), Matchers.is(1));
+                    InfoBar frontInfoBar = mActivityTestRule.getInfoBars().get(0);
+                    Criteria.checkThat(
+                            "Invalid infobar type shown",
+                            frontInfoBar.getInfoBarIdentifier(),
+                            Matchers.is(InfoBarIdentifier.POPUP_BLOCKED_INFOBAR_DELEGATE_MOBILE));
+                });
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/AdblockPopupMessageTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/AdblockPopupMessageTest.java
new file mode 100644
index 0000000000..9701fe61e6
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/AdblockPopupMessageTest.java
@@ -0,0 +1,107 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import androidx.test.InstrumentationRegistry;
+import androidx.test.filters.MediumTest;
+
+import org.hamcrest.Matchers;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.base.test.util.Criteria;
+import org.chromium.base.test.util.CriteriaHelper;
+import org.chromium.base.test.util.Feature;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.browser.tabmodel.TabModelSelector;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.messages.MessagesTestHelper;
+import org.chromium.net.test.EmbeddedTestServer;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class AdblockPopupMessageTest {
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private static final String POPUP_HTML_PATH = "/chrome/test/data/android/popup_test.html";
+
+    private String mPopupHtmlUrl;
+    private EmbeddedTestServer mTestServer;
+
+    @Before
+    public void setUp() throws Exception {
+        // Create a new temporary instance to ensure the Class is loaded. Otherwise we will get a
+        // ClassNotFoundException when trying to instantiate during startup.
+        mActivityTestRule.startMainActivityOnBlankPage();
+
+        mTestServer = EmbeddedTestServer.createAndStartServer(InstrumentationRegistry.getContext());
+        mPopupHtmlUrl = mTestServer.getURL(POPUP_HTML_PATH);
+    }
+
+    @After
+    public void tearDown() {
+        mTestServer.stopAndDestroyServer();
+    }
+
+    public int getTabCount() {
+        final TabModelSelector tabModelSelector =
+                mActivityTestRule.getActivity().getTabModelSelectorSupplier().get();
+        Assert.assertNotNull(tabModelSelector);
+        return tabModelSelector.getTotalTabCount();
+    }
+
+    @Test
+    @MediumTest
+    @Feature({"adblock"})
+    public void popUpBlockedMessageVisibleWhenAbpEnabled() throws InterruptedException {
+        mActivityTestRule.loadUrl(mPopupHtmlUrl);
+        Assert.assertEquals(1, getTabCount());
+
+        CriteriaHelper.pollUiThread(
+                () -> {
+                    Criteria.checkThat(
+                            MessagesTestHelper.getMessageCount(
+                                    mActivityTestRule.getActivity().getWindowAndroid()),
+                            Matchers.is(1));
+                });
+    }
+
+    @Test
+    @MediumTest
+    @CommandLineFlags.Add({"disable-adblock"})
+    @Feature({"adblock"})
+    public void popUpBlockedMessageVisibleWhenAbpDisabled() {
+        mActivityTestRule.loadUrl(mPopupHtmlUrl);
+        Assert.assertEquals(1, getTabCount());
+
+        CriteriaHelper.pollUiThread(
+                () -> {
+                    Criteria.checkThat(
+                            MessagesTestHelper.getMessageCount(
+                                    mActivityTestRule.getActivity().getWindowAndroid()),
+                            Matchers.is(1));
+                });
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/CheckChromeFlagsTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/CheckChromeFlagsTest.java
new file mode 100644
index 0000000000..998bd5317e
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/CheckChromeFlagsTest.java
@@ -0,0 +1,65 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import androidx.test.filters.LargeTest;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.base.test.util.Feature;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestVerificationUtils;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class CheckChromeFlagsTest {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+
+    public static final String CHROME_FLAGS_URL = "chrome://flags/";
+
+    @Test
+    @LargeTest
+    @Feature({"adblock"})
+    public void testCheckChromeFlagsDoesntCrash() throws Exception {
+        mHelper.loadUrl(CHROME_FLAGS_URL);
+        TestVerificationUtils.verifyCondition(mHelper, "document.title == 'Experiments'");
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/DefaultSettingsTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/DefaultSettingsTest.java
new file mode 100644
index 0000000000..4755c3d5b8
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/DefaultSettingsTest.java
@@ -0,0 +1,54 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.DefaultSettingsTestBase;
+import org.chromium.content_public.browser.BrowserContextHandle;
+import org.chromium.content_public.browser.test.util.TestThreadUtils;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class DefaultSettingsTest extends DefaultSettingsTestBase {
+    @Override
+    protected BrowserContextHandle getBrowserContext() {
+        return TestThreadUtils.runOnUiThreadBlockingNoException(
+                () -> {
+                    return ProfileManager.getLastUsedRegularProfile();
+                });
+    }
+
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    @Before
+    public void setUp() {
+        mActivityTestRule.startMainActivityOnBlankPage();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/FilteringConfigurationTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/FilteringConfigurationTest.java
new file mode 100644
index 0000000000..f7afd28cfc
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/FilteringConfigurationTest.java
@@ -0,0 +1,77 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.FilteringConfigurationTestBase;
+import org.chromium.content_public.browser.BrowserContextHandle;
+import org.chromium.content_public.browser.test.util.TestThreadUtils;
+import org.chromium.content_public.common.ContentSwitches;
+
+import java.util.concurrent.TimeoutException;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({
+    ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE,
+    ContentSwitches.HOST_RESOLVER_RULES + "=MAP * 127.0.0.1"
+})
+public class FilteringConfigurationTest extends FilteringConfigurationTestBase {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Override
+    protected void loadTestUrl() throws Exception {
+        mActivityTestRule.loadUrl(mTestUrl, 5);
+    }
+
+    @Override
+    protected BrowserContextHandle getBrowserContext() {
+        return TestThreadUtils.runOnUiThreadBlockingNoException(
+                () -> {
+                    return ProfileManager.getLastUsedRegularProfile();
+                });
+    }
+
+    @Before
+    public void setUp() throws TimeoutException {
+        mActivityTestRule.startMainActivityOnBlankPage();
+        mHelper.setActivityTestRule(mActivityTestRule);
+        super.setUp(mHelper, "/chrome/test/data/adblock/innermost_frame.html");
+    }
+
+    @After
+    @Override
+    public void tearDown() {
+        mHelper.tearDown();
+        super.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/ResourceClassificationNotifierTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/ResourceClassificationNotifierTest.java
new file mode 100644
index 0000000000..6f9c14ad93
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/ResourceClassificationNotifierTest.java
@@ -0,0 +1,151 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import androidx.test.InstrumentationRegistry;
+import androidx.test.filters.LargeTest;
+
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CallbackHelper;
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.base.test.util.Feature;
+import org.chromium.base.test.util.IntegrationTest;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.AdblockController;
+import org.chromium.components.adblock.FilteringConfiguration;
+import org.chromium.components.adblock.ResourceClassificationNotifier;
+import org.chromium.components.adblock.TestResourceFilteringObserver;
+import org.chromium.content_public.browser.test.util.TestThreadUtils;
+import org.chromium.content_public.common.ContentSwitches;
+import org.chromium.net.test.EmbeddedTestServer;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({
+    ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE,
+    ContentSwitches.HOST_RESOLVER_RULES + "=MAP * 127.0.0.1"
+})
+public class ResourceClassificationNotifierTest {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final CallbackHelper mHelper = new CallbackHelper();
+    public FilteringConfiguration mConfiguration;
+    public TestResourceFilteringObserver mResourceFilteringObserver =
+            new TestResourceFilteringObserver();
+
+    private EmbeddedTestServer mTestServer;
+    private String mTestUrl;
+
+    public void loadTestUrl() {
+        mActivityTestRule.loadUrl(mTestUrl, 5);
+    }
+
+    @Before
+    public void setUp() throws TimeoutException {
+        TestThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    mConfiguration =
+                            FilteringConfiguration.createConfiguration(
+                                    "a", ProfileManager.getLastUsedRegularProfile());
+                    ResourceClassificationNotifier.getInstance(
+                                    ProfileManager.getLastUsedRegularProfile())
+                            .addResourceFilteringObserver(mResourceFilteringObserver);
+                    mHelper.notifyCalled();
+                });
+        mHelper.waitForCallback(0, 1, 10, TimeUnit.SECONDS);
+        mActivityTestRule.startMainActivityOnBlankPage();
+        mTestServer = EmbeddedTestServer.createAndStartServer(InstrumentationRegistry.getContext());
+        mTestUrl =
+                mTestServer.getURLWithHostName(
+                        "test.org", "/chrome/test/data/adblock/innermost_frame.html");
+    }
+
+    @After
+    public void tearDown() {
+        mTestServer.stopAndDestroyServer();
+    }
+
+    @Test
+    @IntegrationTest
+    @LargeTest
+    @Feature({"adblock"})
+    public void noNotificationWithoutBlocking() throws Exception {
+        loadTestUrl();
+
+        Assert.assertTrue(mResourceFilteringObserver.blockedInfos.isEmpty());
+        Assert.assertTrue(mResourceFilteringObserver.allowedInfos.isEmpty());
+        Assert.assertTrue(mResourceFilteringObserver.allowedPageInfos.isEmpty());
+    }
+
+    @Test
+    @IntegrationTest
+    @LargeTest
+    @Feature({"adblock"})
+    public void resourceBlockedByFilter() throws Exception {
+        TestThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    mConfiguration.addCustomFilter("resource.png");
+                    mHelper.notifyCalled();
+                });
+        mHelper.waitForCallback(0, 1, 10, TimeUnit.SECONDS);
+        loadTestUrl();
+        // Observer was notified about the blocking
+        Assert.assertTrue(mResourceFilteringObserver.isBlocked("resource.png"));
+        Assert.assertTrue(mResourceFilteringObserver.allowedInfos.isEmpty());
+        Assert.assertTrue(mResourceFilteringObserver.allowedPageInfos.isEmpty());
+    }
+
+    @Test
+    @IntegrationTest
+    @LargeTest
+    @Feature({"adblock"})
+    public void pageAllowed() throws Exception {
+        TestThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    mConfiguration.addCustomFilter("resource.png");
+                    mConfiguration.addAllowedDomain("test.org");
+                    // In general "adblock" configuration does not interfere.
+                    // But for onPageAllowed event all configurations must contain
+                    // page allowing rule so let's add rule there.
+                    AdblockController.getInstance(ProfileManager.getLastUsedRegularProfile())
+                            .addAllowedDomain("test.org");
+                    mHelper.notifyCalled();
+                });
+        mHelper.waitForCallback(0, 1, 10, TimeUnit.SECONDS);
+        loadTestUrl();
+        // Observer was notified about the allowed resource
+        Assert.assertTrue(mResourceFilteringObserver.blockedInfos.isEmpty());
+        Assert.assertTrue(mResourceFilteringObserver.isAllowed("resource.png"));
+        Assert.assertTrue(mResourceFilteringObserver.isPageAllowed("test.org"));
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesCircumventionTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesCircumventionTest.java
new file mode 100644
index 0000000000..b7002b9e53
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesCircumventionTest.java
@@ -0,0 +1,52 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesCircumventionTestBase;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesCircumventionTest extends TestPagesCircumventionTestBase {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesCspTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesCspTest.java
new file mode 100644
index 0000000000..0d4734f0b0
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesCspTest.java
@@ -0,0 +1,52 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesCspTestBase;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesCspTest extends TestPagesCspTestBase {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideEmuInvTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideEmuInvTest.java
new file mode 100644
index 0000000000..3934994558
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideEmuInvTest.java
@@ -0,0 +1,49 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesElemhideEmuInvTestBase;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesElemhideEmuInvTest extends TestPagesElemhideEmuInvTestBase {
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideEmuTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideEmuTest.java
new file mode 100644
index 0000000000..04abe215d0
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideEmuTest.java
@@ -0,0 +1,49 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesElemhideEmuTestBase;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesElemhideEmuTest extends TestPagesElemhideEmuTestBase {
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideTest.java
new file mode 100644
index 0000000000..9250037749
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesElemhideTest.java
@@ -0,0 +1,49 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesElemhideTestBase;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesElemhideTest extends TestPagesElemhideTestBase {
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesExceptionTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesExceptionTest.java
new file mode 100644
index 0000000000..b6c0500220
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesExceptionTest.java
@@ -0,0 +1,108 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import androidx.test.filters.LargeTest;
+
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.task.PostTask;
+import org.chromium.base.task.TaskTraits;
+import org.chromium.base.test.util.CallbackHelper;
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.base.test.util.Feature;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesExceptionTestBase;
+import org.chromium.content_public.browser.test.util.JavaScriptUtils;
+import org.chromium.content_public.common.ContentSwitches;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesExceptionTest extends TestPagesExceptionTestBase {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @Test
+    @LargeTest
+    @Feature({"adblock"})
+    @CommandLineFlags.Add(ContentSwitches.DISABLE_POPUP_BLOCKING)
+    public void testVerifyPopupException() throws Exception {
+        final String POPUP_TESTACE_URL =
+                TestPagesHelper.EXCEPTION_TESTPAGES_TESTCASES_ROOT + "popup";
+        mHelper.loadUrl(POPUP_TESTACE_URL);
+        Assert.assertEquals(1, mHelper.getTabCount());
+        final CallbackHelper tabsLoadedWaiter = mHelper.getTabsOpenedAndLoadedWaiter();
+        PostTask.postTask(
+                TaskTraits.BEST_EFFORT_MAY_BLOCK,
+                () -> {
+                    try {
+                        String numElements =
+                                JavaScriptUtils.executeJavaScriptAndWaitForResult(
+                                        mHelper.getWebContents(),
+                                        "var elements ="
+                                            + " document.getElementsByClassName(\"testcase-trigger\");for"
+                                            + " (let i = 0; i < elements.length; ++i) {   "
+                                            + " elements[i].click();}elements.length;");
+                        Assert.assertEquals("3", numElements);
+                    } catch (TimeoutException e) {
+                        Assert.assertEquals("Popups were triggered", "Popups were NOT triggered");
+                    }
+                });
+        // Wait for three tab loaded events
+        tabsLoadedWaiter.waitForCallback(0, 3, TestPagesHelper.TEST_TIMEOUT_SEC, TimeUnit.SECONDS);
+        Assert.assertEquals(4, mHelper.getTabCount());
+        Assert.assertEquals(3, mHelper.numAllowedPopups());
+        Assert.assertTrue(
+                mHelper.isPopupAllowed(
+                        TestPagesHelper.TESTPAGES_RESOURCES_ROOT + "popup_exception/link.html"));
+        Assert.assertTrue(
+                mHelper.isPopupAllowed(
+                        TestPagesHelper.TESTPAGES_RESOURCES_ROOT
+                                + "popup_exception/script-window.html"));
+        Assert.assertTrue(
+                mHelper.isPopupAllowed(
+                        TestPagesHelper.TESTPAGES_RESOURCES_ROOT
+                                + "popup_exception/script-tab.html"));
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesFilterTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesFilterTest.java
new file mode 100644
index 0000000000..55243e0b32
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesFilterTest.java
@@ -0,0 +1,107 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import androidx.test.filters.LargeTest;
+
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.task.PostTask;
+import org.chromium.base.task.TaskTraits;
+import org.chromium.base.test.util.CallbackHelper;
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.base.test.util.Feature;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesFilterTestBase;
+import org.chromium.content_public.browser.test.util.JavaScriptUtils;
+import org.chromium.content_public.common.ContentSwitches;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesFilterTest extends TestPagesFilterTestBase {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @Test
+    @LargeTest
+    @Feature({"adblock"})
+    @CommandLineFlags.Add(ContentSwitches.DISABLE_POPUP_BLOCKING)
+    public void testVerifyPopupFilters() throws Exception {
+        final String POPUP_TESTACE_URL = TestPagesHelper.FILTER_TESTPAGES_TESTCASES_ROOT + "popup";
+        mHelper.loadUrl(POPUP_TESTACE_URL);
+        Assert.assertEquals(1, mHelper.getTabCount());
+        final CallbackHelper tabsOpenedAndClosedWaiter = mHelper.getTabsOpenedAndClosedWaiter();
+        // Trigger popups which open and close when blocked
+        PostTask.postTask(
+                TaskTraits.BEST_EFFORT_MAY_BLOCK,
+                () -> {
+                    try {
+                        String numElements =
+                                JavaScriptUtils.executeJavaScriptAndWaitForResult(
+                                        mHelper.getWebContents(),
+                                        "var elements ="
+                                            + " document.getElementsByClassName(\"testcase-trigger\");for"
+                                            + " (let i = 0; i < elements.length; ++i) {   "
+                                            + " elements[i].click();}elements.length;");
+                        Assert.assertEquals("3", numElements);
+                    } catch (TimeoutException e) {
+                        Assert.assertEquals("Popups were triggered", "Popups were NOT triggered");
+                    }
+                });
+        // Wait for three tab open events and three close tabs events
+        tabsOpenedAndClosedWaiter.waitForCallback(
+                0, 6, TestPagesHelper.TEST_TIMEOUT_SEC, TimeUnit.SECONDS);
+        Assert.assertEquals(3, mHelper.numBlockedPopups());
+        Assert.assertTrue(
+                mHelper.isPopupBlocked(
+                        TestPagesHelper.TESTPAGES_RESOURCES_ROOT + "popup/link.html"));
+        Assert.assertTrue(
+                mHelper.isPopupBlocked(
+                        TestPagesHelper.TESTPAGES_RESOURCES_ROOT + "popup/script-window.html"));
+        Assert.assertTrue(
+                mHelper.isPopupBlocked(
+                        TestPagesHelper.TESTPAGES_RESOURCES_ROOT + "popup/script-tab.html"));
+        Assert.assertEquals(1, mHelper.getTabCount());
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesHeaderFilterTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesHeaderFilterTest.java
new file mode 100644
index 0000000000..fe13c8b966
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesHeaderFilterTest.java
@@ -0,0 +1,52 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesHeaderFilterTestBase;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesHeaderFilterTest extends TestPagesHeaderFilterTestBase {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesHelper.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesHelper.java
new file mode 100644
index 0000000000..9cb00e4357
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesHelper.java
@@ -0,0 +1,144 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.Assert;
+
+import org.chromium.base.test.util.CallbackHelper;
+import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.chrome.browser.tab.EmptyTabObserver;
+import org.chromium.chrome.browser.tab.Tab;
+import org.chromium.chrome.browser.tab.Tab.LoadUrlResult;
+import org.chromium.chrome.browser.tabmodel.TabModelObserver;
+import org.chromium.chrome.browser.tabmodel.TabModelSelector;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesHelperBase;
+import org.chromium.content_public.browser.BrowserContextHandle;
+import org.chromium.content_public.browser.WebContents;
+import org.chromium.content_public.browser.test.util.TestThreadUtils;
+import org.chromium.url.GURL;
+
+import java.util.concurrent.TimeoutException;
+
+public class TestPagesHelper extends TestPagesHelperBase {
+    private ChromeTabbedActivityTestRule mActivityTestRule;
+
+    public void setActivityTestRule(ChromeTabbedActivityTestRule activityTestRule) {
+        mActivityTestRule = activityTestRule;
+    }
+
+    public void setUp(final ChromeTabbedActivityTestRule activityRule) {
+        mActivityTestRule = activityRule;
+        mActivityTestRule.startMainActivityOnBlankPage();
+        mActivityTestRule.waitForActivityNativeInitializationComplete();
+        super.setUp();
+    }
+
+    public CallbackHelper getTabsOpenedAndClosedWaiter() {
+        final CallbackHelper callbackHelper = new CallbackHelper();
+        final TabModelSelector tabModelSelector =
+                mActivityTestRule.getActivity().getTabModelSelectorSupplier().get();
+        Assert.assertNotNull(tabModelSelector);
+        TestThreadUtils.runOnUiThreadBlocking(
+                () ->
+                        tabModelSelector
+                                .getCurrentModel()
+                                .addObserver(
+                                        new TabModelObserver() {
+                                            @Override
+                                            public void onFinishingTabClosure(Tab tab) {
+                                                // For some reason TabModelObserver#tabRemoved() is
+                                                // not called.
+                                                // Let's wait a bit to make sure tab is indeed
+                                                // closed.
+                                                try {
+                                                    Thread.sleep(100);
+                                                } catch (InterruptedException ignored) {
+                                                }
+                                                callbackHelper.notifyCalled();
+                                            }
+
+                                            @Override
+                                            public void didAddTab(
+                                                    Tab tab,
+                                                    int type,
+                                                    int creationState,
+                                                    boolean markedForSelection) {
+                                                callbackHelper.notifyCalled();
+                                            }
+                                        }));
+        return callbackHelper;
+    }
+
+    public CallbackHelper getTabsOpenedAndLoadedWaiter() {
+        final CallbackHelper callbackHelper = new CallbackHelper();
+        final TabModelSelector tabModelSelector =
+                mActivityTestRule.getActivity().getTabModelSelectorSupplier().get();
+        Assert.assertNotNull(tabModelSelector);
+        TestThreadUtils.runOnUiThreadBlocking(
+                () ->
+                        tabModelSelector
+                                .getCurrentModel()
+                                .addObserver(
+                                        new TabModelObserver() {
+                                            @Override
+                                            public void didAddTab(
+                                                    Tab tab,
+                                                    int type,
+                                                    int creationState,
+                                                    boolean markedForSelection) {
+                                                tab.addObserver(
+                                                        new EmptyTabObserver() {
+                                                            @Override
+                                                            public void onPageLoadFinished(
+                                                                    Tab tab, GURL url) {
+                                                                callbackHelper.notifyCalled();
+                                                            }
+                                                        });
+                                            }
+                                        }));
+        return callbackHelper;
+    }
+
+    public int getTabCount() {
+        final TabModelSelector tabModelSelector =
+                mActivityTestRule.getActivity().getTabModelSelectorSupplier().get();
+        Assert.assertNotNull(tabModelSelector);
+        return tabModelSelector.getTotalTabCount();
+    }
+
+    @Override
+    public BrowserContextHandle getBrowserContext() {
+        return ProfileManager.getLastUsedRegularProfile();
+    }
+
+    @Override
+    public WebContents getWebContents() {
+        return mActivityTestRule.getActivity().getCurrentWebContents();
+    }
+
+    @Override
+    public void loadUrl(final String url) throws InterruptedException, TimeoutException {
+        final LoadUrlResult result = mActivityTestRule.loadUrl(url, TEST_TIMEOUT_SEC);
+        Assert.assertEquals(
+                "Page did not load correctly. Load result enum: "
+                        + String.valueOf(result.tabLoadStatus),
+                result.tabLoadStatus,
+                Tab.TabLoadStatus.DEFAULT_PAGE_LOAD);
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesInlineCssTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesInlineCssTest.java
new file mode 100644
index 0000000000..6b6e5596d7
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesInlineCssTest.java
@@ -0,0 +1,49 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesInlineCssTestBase;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesInlineCssTest extends TestPagesInlineCssTestBase {
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesRemoveTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesRemoveTest.java
new file mode 100644
index 0000000000..01108ab215
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesRemoveTest.java
@@ -0,0 +1,49 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesRemoveTestBase;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesRemoveTest extends TestPagesRemoveTestBase {
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesRewriteTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesRewriteTest.java
new file mode 100644
index 0000000000..700fc8de41
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesRewriteTest.java
@@ -0,0 +1,52 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesRewriteTestBase;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesRewriteTest extends TestPagesRewriteTestBase {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesSiteKeyTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesSiteKeyTest.java
new file mode 100644
index 0000000000..9658cb91d1
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesSiteKeyTest.java
@@ -0,0 +1,52 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesSiteKeyTestBase;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesSiteKeyTest extends TestPagesSiteKeyTestBase {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesSnippetsTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesSnippetsTest.java
new file mode 100644
index 0000000000..680aebab8f
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesSnippetsTest.java
@@ -0,0 +1,52 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesSnippetsTestBase;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesSnippetsTest extends TestPagesSnippetsTestBase {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesWebsocketTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesWebsocketTest.java
new file mode 100644
index 0000000000..e6135f69a5
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesWebsocketTest.java
@@ -0,0 +1,52 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesWebsocketTestBase;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesWebsocketTest extends TestPagesWebsocketTestBase {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesWildcardDomainTest.java b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesWildcardDomainTest.java
new file mode 100644
index 0000000000..a847b5e59f
--- /dev/null
+++ b/chrome/browser/adblock/android/javatests/src/org/chromium/chrome/browser/adblock/TestPagesWildcardDomainTest.java
@@ -0,0 +1,52 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package org.chromium.chrome.browser.adblock;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.runner.RunWith;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.ChromeTabbedActivityTestRule;
+import org.chromium.components.adblock.TestPagesWildcardDomainTestBase;
+
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class TestPagesWildcardDomainTest extends TestPagesWildcardDomainTestBase {
+    @Rule public final ChromeBrowserTestRule mBrowserTestRule = new ChromeBrowserTestRule();
+
+    @Rule
+    public ChromeTabbedActivityTestRule mActivityTestRule = new ChromeTabbedActivityTestRule();
+
+    private final TestPagesHelper mHelper = new TestPagesHelper();
+
+    @Before
+    public void setUp() {
+        mHelper.setUp(mActivityTestRule);
+        super.setUp(mHelper);
+    }
+
+    @After
+    public void tearDown() {
+        mHelper.tearDown();
+    }
+}
diff --git a/chrome/browser/adblock/test/adblock_acceptable_ads_browsertest.cc b/chrome/browser/adblock/test/adblock_acceptable_ads_browsertest.cc
new file mode 100644
index 0000000000..9f4e079dc3
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_acceptable_ads_browsertest.cc
@@ -0,0 +1,279 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "base/environment.h"
+#include "base/run_loop.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/adblock_filter_match.h"
+#include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/resource_classification_runner.h"
+#include "components/adblock/core/adblock_switches.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_config.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+
+namespace adblock {
+namespace {
+class SubscriptionInstalledWaiter
+    : public SubscriptionService::SubscriptionObserver {
+ public:
+  explicit SubscriptionInstalledWaiter(
+      SubscriptionService* subscription_service)
+      : subscription_service_(subscription_service) {
+    subscription_service_->AddObserver(this);
+  }
+
+  ~SubscriptionInstalledWaiter() override {
+    subscription_service_->RemoveObserver(this);
+  }
+
+  void WaitUntilSubscriptionsInstalled(std::vector<std::string> subscriptions) {
+    awaited_subscriptions_ = std::move(subscriptions);
+    run_loop_.Run();
+  }
+
+  void OnSubscriptionInstalled(const GURL& subscription_url) override {
+    awaited_subscriptions_.erase(
+        base::ranges::remove(awaited_subscriptions_, subscription_url.path()),
+        awaited_subscriptions_.end());
+    if (awaited_subscriptions_.empty()) {
+      run_loop_.Quit();
+    }
+  }
+
+ protected:
+  raw_ptr<SubscriptionService> subscription_service_;
+  base::RunLoop run_loop_;
+  std::vector<std::string> awaited_subscriptions_;
+};
+
+class ResourceClassificationRunnerObserver
+    : public ResourceClassificationRunner::Observer {
+ public:
+  // ResourceClassificationRunner::Observer:
+  void OnRequestMatched(const GURL& url,
+                        FilterMatchResult match_result,
+                        const std::vector<GURL>& parent_frame_urls,
+                        ContentType content_type,
+                        content::RenderFrameHost* render_frame_host,
+                        const GURL& subscription,
+                        const std::string& configuration_name) override {
+    if (match_result == FilterMatchResult::kAllowRule) {
+      allowed_ads_notifications.push_back(url);
+    } else {
+      blocked_ads_notifications.push_back(url);
+    }
+  }
+
+  void OnPageAllowed(const GURL& url,
+                     content::RenderFrameHost* render_frame_host,
+                     const GURL& subscription,
+                     const std::string& configuration_name) override {
+    allowed_pages_notifications.push_back(url);
+  }
+
+  void OnPopupMatched(const GURL& url,
+                      FilterMatchResult match_result,
+                      const GURL& opener_url,
+                      content::RenderFrameHost* render_frame_host,
+                      const GURL& subscription,
+                      const std::string& configuration_name) override {}
+
+  std::vector<GURL> blocked_ads_notifications;
+  std::vector<GURL> allowed_ads_notifications;
+  std::vector<GURL> allowed_pages_notifications;
+};
+}  // namespace
+
+class AdblockAcceptableAdsTest
+    : public InProcessBrowserTest,
+      public testing::WithParamInterface<std::tuple<bool, bool, bool>> {
+ public:
+  AdblockAcceptableAdsTest()
+      : https_server_(net::EmbeddedTestServer::TYPE_HTTPS) {
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+    setenv("LANGUAGE", "en_US", 1);
+#endif
+  }
+
+  // We need to set server and request handler asap
+  void SetUpInProcessBrowserTestFixture() override {
+    InProcessBrowserTest::SetUpInProcessBrowserTestFixture();
+    host_resolver()->AddRule("easylist-downloads.adblockplus.org", "127.0.0.1");
+    host_resolver()->AddRule(kTestDomain, "127.0.0.1");
+    https_server_.ServeFilesFromSourceDirectory("chrome/test/data/adblock");
+    https_server_.RegisterRequestHandler(base::BindRepeating(
+        &AdblockAcceptableAdsTest::RequestHandler, base::Unretained(this)));
+    net::EmbeddedTestServer::ServerCertificateConfig cert_config;
+    cert_config.dns_names = {"easylist-downloads.adblockplus.org", kTestDomain};
+    https_server_.SetSSLConfig(cert_config);
+    ASSERT_TRUE(https_server_.Start());
+    SetFilterListServerPortForTesting(https_server_.port());
+  }
+
+  void SetUpOnMainThread() override {
+    InProcessBrowserTest::SetUpOnMainThread();
+    auto* classification_runner =
+        ResourceClassificationRunnerFactory::GetForBrowserContext(
+            browser()->profile()->GetOriginalProfile());
+    DCHECK(classification_runner);
+    classification_runner->AddObserver(&observer);
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(
+            browser()->profile()->GetOriginalProfile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    DCHECK(adblock_configuration);
+    adblock_configuration->RemoveCustomFilter(kAllowlistEverythingFilter);
+    if (DomainAllowlisted()) {
+      adblock_configuration->AddAllowedDomain(kTestDomain);
+    }
+  }
+
+  void TearDownOnMainThread() override {
+    auto* classification_runner =
+        ResourceClassificationRunnerFactory::GetForBrowserContext(
+            browser()->profile()->GetOriginalProfile());
+    classification_runner->RemoveObserver(&observer);
+    InProcessBrowserTest::TearDownOnMainThread();
+  }
+
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    if (!AcceptableAdsEnabled()) {
+      command_line->AppendSwitch(switches::kDisableAcceptableAds);
+    }
+    if (IncognitoMode()) {
+      command_line->AppendSwitch(::switches::kIncognito);
+    }
+  }
+
+  void WaitUntilSubscriptionsInstalled() {
+    std::vector<std::string> subscriptions = {DefaultSubscriptionUrl().path()};
+    if (AcceptableAdsEnabled()) {
+      subscriptions.emplace_back(AcceptableAdsUrl().path());
+    }
+    SubscriptionInstalledWaiter waiter(
+        SubscriptionServiceFactory::GetForBrowserContext(
+            browser()->profile()->GetOriginalProfile()));
+    waiter.WaitUntilSubscriptionsInstalled(std::move(subscriptions));
+  }
+
+  virtual std::unique_ptr<net::test_server::HttpResponse> RequestHandler(
+      const net::test_server::HttpRequest& request) {
+    if (request.GetURL().path() == AcceptableAdsUrl().path()) {
+      std::unique_ptr<net::test_server::BasicHttpResponse> http_response(
+          new net::test_server::BasicHttpResponse);
+      http_response->set_code(net::HTTP_OK);
+      http_response->set_content(
+          "[Adblock Plus 2.0]\n\n"
+          "@@*resource.png\n");
+      http_response->set_content_type("text/plain");
+      return std::move(http_response);
+    } else if (request.GetURL().path() == DefaultSubscriptionUrl().path()) {
+      std::unique_ptr<net::test_server::BasicHttpResponse> http_response(
+          new net::test_server::BasicHttpResponse);
+      http_response->set_code(net::HTTP_OK);
+      http_response->set_content(
+          "[Adblock Plus 2.0]\n\n"
+          "*resource.png\n");
+      http_response->set_content_type("text/plain");
+      return std::move(http_response);
+    }
+
+    // Unhandled requests result in the Embedded test server sending a 404. This
+    // is fine for the purpose of this test.
+    return nullptr;
+  }
+
+  GURL GetPageUrl(const std::string& path = "/innermost_frame.html") {
+    return https_server_.GetURL(kTestDomain, path);
+  }
+
+  void NavigateToPage() {
+    ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetPageUrl()));
+  }
+
+  void VerifyExpectedNotifications() {
+    if (AcceptableAdsEnabled() || DomainAllowlisted()) {
+      ASSERT_EQ(observer.allowed_ads_notifications.size(), 1u);
+      EXPECT_TRUE(observer.allowed_ads_notifications.front() ==
+                  GetPageUrl("/resource.png"))
+          << "Request not allowed!";
+      if (DomainAllowlisted()) {
+        ASSERT_EQ(observer.allowed_pages_notifications.size(), 1u);
+        EXPECT_TRUE(observer.allowed_pages_notifications.front() ==
+                    GetPageUrl())
+            << "Page not allowed!";
+      }
+    } else {
+      ASSERT_EQ(observer.blocked_ads_notifications.size(), 1u);
+      EXPECT_TRUE(observer.blocked_ads_notifications.front() ==
+                  GetPageUrl("/resource.png"))
+          << "Request not blocked!";
+      EXPECT_TRUE(observer.allowed_ads_notifications.empty());
+      EXPECT_TRUE(observer.allowed_pages_notifications.empty());
+    }
+  }
+
+  bool AcceptableAdsEnabled() { return std::get<0>(GetParam()); }
+
+  bool DomainAllowlisted() { return std::get<1>(GetParam()); }
+
+  bool IncognitoMode() { return std::get<2>(GetParam()); }
+
+ private:
+  net::EmbeddedTestServer https_server_;
+  ResourceClassificationRunnerObserver observer;
+  static constexpr char kTestDomain[] = "test.org";
+};
+
+IN_PROC_BROWSER_TEST_P(AdblockAcceptableAdsTest, VerifyAcceptableAds) {
+  auto* adblock_configuration =
+      SubscriptionServiceFactory::GetForBrowserContext(
+          browser()->profile()->GetOriginalProfile())
+          ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+  DCHECK(adblock_configuration);
+  auto subscriptions = adblock_configuration->GetFilterLists();
+  // This remove/add dance is required to avoid race when we are not sure
+  // if subscriptions were already installed or not. It's difficult to set
+  // SubscriptionObserver for built-in subscriptions in right time during
+  // test setup so we do it here and by Remove() then Add() we trigger
+  // filter lists installations which we then observe and block until done.
+  for (const auto& subscription : subscriptions) {
+    adblock_configuration->RemoveFilterList(subscription);
+    adblock_configuration->AddFilterList(subscription);
+  }
+  WaitUntilSubscriptionsInstalled();
+  NavigateToPage();
+  VerifyExpectedNotifications();
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    All,
+    AdblockAcceptableAdsTest,
+    testing::Combine(/* AA on/off */ testing::Bool(),
+                     /* Allowlist domain */ testing::Bool(),
+                     /* Incognito on/off */ testing::Bool()));
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_chrome_content_browser_client_browsertest.cc b/chrome/browser/adblock/test/adblock_chrome_content_browser_client_browsertest.cc
new file mode 100644
index 0000000000..6be2b37763
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_chrome_content_browser_client_browsertest.cc
@@ -0,0 +1,126 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "chrome/browser/adblock/adblock_chrome_content_browser_client.h"
+
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_commands.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/common/adblock_prefs.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "components/adblock/core/subscription/test/mock_subscription_service.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "net/test/spawned_test_server/spawned_test_server.h"
+#include "net/test/test_data_directory.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace adblock {
+
+class AdblockChromeContentBrowserClientBrowserTest : public InProcessBrowserTest {
+ public:
+  void SetUpOnMainThread() override {
+    watcher_ = std::make_unique<content::TitleWatcher>(
+        browser()->tab_strip_model()->GetActiveWebContents(), u"PASS");
+    watcher_->AlsoWaitForTitle(u"FAIL");
+    embedded_test_server()->ServeFilesFromSourceDirectory(
+        net::GetWebSocketTestDataDirectory());
+    ASSERT_TRUE(embedded_test_server()->Start());
+  }
+
+  void TearDownOnMainThread() override { watcher_.reset(); }
+
+  void NavigateToHTTP(const std::string& path) {
+    // Visit a HTTPS page for testing.
+    GURL::Replacements replacements;
+    replacements.SetSchemeStr("http");
+    ASSERT_TRUE(ui_test_utils::NavigateToURL(
+        browser(), ws_server_.GetURL(path).ReplaceComponents(replacements)));
+  }
+
+  std::string WaitAndGetTitle() {
+    return base::UTF16ToUTF8(watcher_->WaitAndGetTitle());
+  }
+
+  net::SpawnedTestServer ws_server_{net::SpawnedTestServer::TYPE_WS,
+                                    net::GetWebSocketTestDataDirectory()};
+
+ private:
+  std::unique_ptr<content::TitleWatcher> watcher_;
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockChromeContentBrowserClientBrowserTest,
+                       WebSocketConnectionNotInterrupted) {
+  // Launch a WebSocket server.
+  ASSERT_TRUE(ws_server_.Start());
+
+  // Disable ad-filtering.
+  auto* adblock_configuration =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+  adblock_configuration->SetEnabled(false);
+
+  NavigateToHTTP("split_packet_check.html");
+
+  // WebSocket connected.
+  EXPECT_EQ("PASS", WaitAndGetTitle());
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockChromeContentBrowserClientBrowserTest,
+                       WebSocketConnectionInterruptedButNotBlocked) {
+  // Launch a WebSocket server.
+  ASSERT_TRUE(ws_server_.Start());
+
+  // Enable ad-filtering.
+  auto* adblock_configuration =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+  adblock_configuration->SetEnabled(true);
+
+  NavigateToHTTP("split_packet_check.html");
+
+  // WebSocket connected, there were no blocking filters.
+  EXPECT_EQ("PASS", WaitAndGetTitle());
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockChromeContentBrowserClientBrowserTest,
+                       WebSocketConnectionInterruptedAndBlocked) {
+  // Launch a WebSocket server.
+  ASSERT_TRUE(ws_server_.Start());
+
+  // Intercept WebSocket and block connection via a filter.
+  auto* adblock_configuration =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+  adblock_configuration->SetEnabled(true);
+  adblock_configuration->RemoveCustomFilter(kAllowlistEverythingFilter);
+  adblock_configuration->AddCustomFilter({"*$websocket"});
+
+  NavigateToHTTP("split_packet_check.html");
+
+  // WebSocket did not connect.
+  EXPECT_EQ("FAIL", WaitAndGetTitle());
+}
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_content_filters_browsertest.cc b/chrome/browser/adblock/test/adblock_content_filters_browsertest.cc
new file mode 100644
index 0000000000..539280797a
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_content_filters_browsertest.cc
@@ -0,0 +1,326 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <vector>
+
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace adblock {
+
+class AdblockContentFiltersBrowserTest : public InProcessBrowserTest {
+ public:
+  void SetUpOnMainThread() override {
+    InProcessBrowserTest::SetUpOnMainThread();
+    host_resolver()->AddRule("example.com", "127.0.0.1");
+    embedded_test_server()->ServeFilesFromSourceDirectory(
+        "chrome/test/data/adblock");
+    ASSERT_TRUE(embedded_test_server()->Start());
+  }
+
+  void SetFilters(std::vector<std::string> filters) {
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    adblock_configuration->RemoveCustomFilter(kAllowlistEverythingFilter);
+    for (auto& filter : filters) {
+      adblock_configuration->AddCustomFilter(filter);
+    }
+  }
+
+  GURL GetUrl(const std::string& path) {
+    return embedded_test_server()->GetURL("example.com", path);
+  }
+
+  void WaitForDynamicContentLoaded() {
+    std::string dynamic_content_loaded =
+        "window.dynamic_content_loaded == true";
+    ASSERT_TRUE(WaitAndVerifyCondition(dynamic_content_loaded.c_str()));
+  }
+
+  void VerifyTargetsRemoved(bool removed, const std::string& class_id) {
+    std::string is_removed_js =
+        base::StringPrintf("document.getElementsByClassName('%s').length == %d",
+                           class_id.c_str(), removed ? 0 : 2);
+    EXPECT_TRUE(WaitAndVerifyCondition(is_removed_js.c_str()));
+  }
+
+  void VerifyTargetHidden(bool hidden, const std::string& id) {
+    std::string expected_visibility = (hidden ? "none" : "inline");
+    std::string is_hidden_js = base::StringPrintf(
+        "window.getComputedStyle(document.getElementById('%s'))."
+        "display == '%s'",
+        id.c_str(), expected_visibility.c_str());
+    EXPECT_TRUE(WaitAndVerifyCondition(is_hidden_js.c_str()));
+  }
+
+  void VerifyTargetsHidden(bool hidden, const std::string& class_id) {
+    std::string expected_visibility = (hidden ? "none" : "inline");
+    std::string is_hidden_js = base::StringPrintf(
+        "window.getComputedStyle(document.getElementsByClassName('%s')[0])."
+        "display == '%s' && "
+        "window.getComputedStyle(document.getElementsByClassName('%s')[1])."
+        "display == '%s'",
+        class_id.c_str(), expected_visibility.c_str(), class_id.c_str(),
+        expected_visibility.c_str());
+    EXPECT_TRUE(WaitAndVerifyCondition(is_hidden_js.c_str()));
+  }
+
+  void VerifyCssAppliedForTarget(bool applied, const std::string& id) {
+    std::string expected_css = (applied ? "rgb(0, 255, 0)" : "rgb(255, 0, 0)");
+    std::string is_css_applied_js = base::StringPrintf(
+        "window.getComputedStyle(document.getElementById('%s'))."
+        "backgroundColor == '%s'",
+        id.c_str(), expected_css.c_str());
+    EXPECT_TRUE(WaitAndVerifyCondition(is_css_applied_js.c_str()));
+  }
+
+  void VerifyCssAppliedForTargets(bool applied, const std::string& class_id) {
+    std::string expected_css = (applied ? "rgb(0, 255, 0)" : "rgb(255, 0, 0)");
+    std::string is_css_applied_js = base::StringPrintf(
+        "window.getComputedStyle(document.getElementsByClassName('%s')[0])."
+        "backgroundColor == '%s' && "
+        "window.getComputedStyle(document.getElementsByClassName('%s')[1])."
+        "backgroundColor == '%s'",
+        class_id.c_str(), expected_css.c_str(), class_id.c_str(),
+        expected_css.c_str());
+    EXPECT_TRUE(WaitAndVerifyCondition(is_css_applied_js.c_str()));
+  }
+
+ protected:
+  // Because EHE script has some delay before is acts on DOM changes we
+  // need to poll and wait for expected condition to happen.
+  bool WaitAndVerifyCondition(const char* condition) {
+    std::string script = base::StringPrintf(
+        R"(
+      (async () => {
+        let count = 10;
+        function waitFor(condition) {
+          const poll = resolve => {
+            if(condition() || !count--) resolve();
+            else setTimeout(_ => poll(resolve), 300);
+          }
+          return new Promise(poll);
+        }
+        // Waits up to 3 seconds
+        await waitFor(_ => %s);
+        return %s;
+     })()
+     )",
+        condition, condition);
+    return content::EvalJs(browser()->tab_strip_model()->GetActiveWebContents(),
+                           script) == true;
+  }
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockContentFiltersBrowserTest, VerifyNoFilters) {
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(), GetUrl("/content_type_filters.html")));
+  WaitForDynamicContentLoaded();
+  VerifyTargetsHidden(false, "id_to_elem_hide");
+  VerifyTargetsHidden(false, "id_to_elem_hide_emu");
+  VerifyTargetsRemoved(false, "id_to_remove_by_eh");
+  VerifyTargetsRemoved(false, "id_to_remove_by_ehe");
+  VerifyCssAppliedForTargets(false, "id_to_apply_style_by_eh");
+  VerifyCssAppliedForTargets(false, "id_to_apply_style_by_ehe");
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockContentFiltersBrowserTest, VerifyHide) {
+  SetFilters({"example.com##.id_to_elem_hide",
+              "example.com#?#span:-abp-contains(id_to_elem_hide_emu)"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(), GetUrl("/content_type_filters.html")));
+  WaitForDynamicContentLoaded();
+  VerifyTargetsHidden(true, "id_to_elem_hide");
+  VerifyTargetsHidden(true, "id_to_elem_hide_emu");
+  VerifyTargetsRemoved(false, "id_to_remove_by_eh");
+  VerifyTargetsRemoved(false, "id_to_remove_by_ehe");
+  VerifyCssAppliedForTargets(false, "id_to_apply_style_by_eh");
+  VerifyCssAppliedForTargets(false, "id_to_apply_style_by_ehe");
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockContentFiltersBrowserTest, VerifyHideException) {
+  SetFilters({"example.com##.id_to_elem_hide",
+              "example.com#?#span:-abp-contains(id_to_elem_hide_emu)",
+              "example.com#@#.id_to_elem_hide",
+              "example.com#@#span:-abp-contains(id_to_elem_hide_emu)"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(), GetUrl("/content_type_filters.html")));
+  WaitForDynamicContentLoaded();
+  VerifyTargetsHidden(false, "id_to_elem_hide");
+  VerifyTargetsHidden(false, "id_to_elem_hide_emu");
+  VerifyTargetsRemoved(false, "id_to_remove_by_eh");
+  VerifyTargetsRemoved(false, "id_to_remove_by_ehe");
+  VerifyCssAppliedForTargets(false, "id_to_apply_style_by_eh");
+  VerifyCssAppliedForTargets(false, "id_to_apply_style_by_ehe");
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockContentFiltersBrowserTest, VerifyRemove) {
+  SetFilters({"example.com##.id_to_remove_by_eh {remove: true;}",
+              "example.com#?#span:-abp-contains(id_to_remove_by_ehe) {remove: "
+              "true;}"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(), GetUrl("/content_type_filters.html")));
+  WaitForDynamicContentLoaded();
+  VerifyTargetsHidden(false, "id_to_elem_hide");
+  VerifyTargetsHidden(false, "id_to_elem_hide_emu");
+  VerifyTargetsRemoved(true, "id_to_remove_by_eh");
+  VerifyTargetsRemoved(true, "id_to_remove_by_ehe");
+  VerifyCssAppliedForTargets(false, "id_to_apply_style_by_eh");
+  VerifyCssAppliedForTargets(false, "id_to_apply_style_by_ehe");
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockContentFiltersBrowserTest,
+                       VerifyRemoveException) {
+  SetFilters({"example.com##.id_to_remove_by_eh {remove: true;}",
+              "example.com#?#span:-abp-contains(id_to_remove_by_ehe\"]"
+              ") {remove: true;}",
+              "example.com#@#.id_to_remove_by_eh",
+              "example.com#@#span:-abp-contains(id_to_remove_by_ehe)"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(), GetUrl("/content_type_filters.html")));
+  WaitForDynamicContentLoaded();
+  VerifyTargetsHidden(false, "id_to_elem_hide");
+  VerifyTargetsHidden(false, "id_to_elem_hide_emu");
+  VerifyTargetsRemoved(false, "id_to_remove_by_eh");
+  VerifyTargetsRemoved(false, "id_to_remove_by_ehe");
+  VerifyCssAppliedForTargets(false, "id_to_apply_style_by_eh");
+  VerifyCssAppliedForTargets(false, "id_to_apply_style_by_ehe");
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockContentFiltersBrowserTest, VerifyInlineCss) {
+  SetFilters(
+      {"example.com##.id_to_apply_style_by_eh {background-color: "
+       "#00FF00!important;}",
+       "example.com#?#span:-abp-contains(id_to_apply_style_by_ehe) "
+       "{background-color: #00FF00!important;}"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(), GetUrl("/content_type_filters.html")));
+  WaitForDynamicContentLoaded();
+  VerifyTargetsHidden(false, "id_to_elem_hide");
+  VerifyTargetsHidden(false, "id_to_elem_hide_emu");
+  VerifyTargetsRemoved(false, "id_to_remove_by_eh");
+  VerifyTargetsRemoved(false, "id_to_remove_by_ehe");
+  VerifyCssAppliedForTargets(true, "id_to_apply_style_by_eh");
+  VerifyCssAppliedForTargets(true, "id_to_apply_style_by_ehe");
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockContentFiltersBrowserTest,
+                       VerifyInlineCssException) {
+  SetFilters(
+      {"example.com##.id_to_apply_style_by_eh {background-color: "
+       "#00FF00!important;}",
+       "example.com#?#span:-abp-contains(id_to_apply_style_by_ehe) "
+       "{background-color: #00FF00!important;}",
+       "example.com#@#.id_to_apply_style_by_eh",
+       "example.com#@#span:-abp-contains(id_to_apply_style_by_ehe)"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(), GetUrl("/content_type_filters.html")));
+  WaitForDynamicContentLoaded();
+  VerifyTargetsHidden(false, "id_to_elem_hide");
+  VerifyTargetsHidden(false, "id_to_elem_hide_emu");
+  VerifyTargetsRemoved(false, "id_to_remove_by_eh");
+  VerifyTargetsRemoved(false, "id_to_remove_by_ehe");
+  VerifyCssAppliedForTargets(false, "id_to_apply_style_by_eh");
+  VerifyCssAppliedForTargets(false, "id_to_apply_style_by_ehe");
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockContentFiltersBrowserTest, VerifyAllFilters) {
+  SetFilters({"example.com##.id_to_elem_hide",
+              "example.com#?#span:-abp-contains(id_to_elem_hide_emu)",
+              "example.com##.id_to_remove_by_eh {remove: true;}",
+              "example.com#?#span:-abp-contains(id_to_remove_by_ehe) {"
+              "remove: true;}",
+              "example.com##.id_to_apply_style_by_eh {background-color: "
+              "#00FF00!important;}",
+              "example.com#?#span:-abp-contains(id_to_apply_style_by_ehe) "
+              "{background-color: #00FF00!important;}"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(), GetUrl("/content_type_filters.html")));
+  WaitForDynamicContentLoaded();
+  VerifyTargetsHidden(true, "id_to_elem_hide");
+  VerifyTargetsHidden(true, "id_to_elem_hide_emu");
+  VerifyTargetsRemoved(true, "id_to_remove_by_eh");
+  VerifyTargetsRemoved(true, "id_to_remove_by_ehe");
+  VerifyCssAppliedForTargets(true, "id_to_apply_style_by_eh");
+  VerifyCssAppliedForTargets(true, "id_to_apply_style_by_ehe");
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockContentFiltersBrowserTest,
+                       VerifyHideToInlineCssSelectorChange) {
+  SetFilters({"example.com#?#span:-abp-contains(hide_selector)",
+              "example.com#?#span:-abp-contains(inline_css_selector) "
+              "{background-color: #00FF00!important;}"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(), GetUrl("/content_type_filters.html")));
+  VerifyTargetHidden(false, "changing_element");
+  VerifyCssAppliedForTarget(false, "changing_element");
+  EXPECT_EQ(
+      "hide_selector",
+      content::EvalJs(browser()->tab_strip_model()->GetActiveWebContents(),
+                      "document.getElementById('changing_element').innerHTML = "
+                      "'hide_selector'"));
+  VerifyTargetHidden(true, "changing_element");
+  VerifyCssAppliedForTarget(false, "changing_element");
+  EXPECT_EQ(
+      "inline_css_selector",
+      content::EvalJs(browser()->tab_strip_model()->GetActiveWebContents(),
+                      "document.getElementById('changing_element').innerHTML = "
+                      "'inline_css_selector'"));
+  VerifyTargetHidden(false, "changing_element");
+  VerifyCssAppliedForTarget(true, "changing_element");
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockContentFiltersBrowserTest,
+                       VerifyInlineCssStyleModificationLogic) {
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(), GetUrl("/content_type_filters.html")));
+  const char* get_expected_style_property =
+      "document.getElementById('changing_element').style['%s'] === '%s'";
+  EXPECT_TRUE(WaitAndVerifyCondition(
+      base::StringPrintf(get_expected_style_property, "background-color",
+                         "rgb(255, 0, 0)")
+          .c_str()));
+  EXPECT_TRUE(WaitAndVerifyCondition(
+      base::StringPrintf(get_expected_style_property, "width", "").c_str()));
+  SetFilters(
+      {"example.com###changing_element {background-color: #00FF00!important;}",
+       "example.com###changing_element {width: 100px;}"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(), GetUrl("/content_type_filters.html")));
+  // "background-color" is now overwritten (update logic for existing property)
+  EXPECT_TRUE(WaitAndVerifyCondition(
+      base::StringPrintf(get_expected_style_property, "background-color",
+                         "rgb(0, 255, 0)")
+          .c_str()));
+  // "width" is now set (add logic for not yet set property)
+  EXPECT_TRUE(WaitAndVerifyCondition(
+      base::StringPrintf(get_expected_style_property, "width", "100px")
+          .c_str()));
+}
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_debug_url_browsertest.cc b/chrome/browser/adblock/test/adblock_debug_url_browsertest.cc
new file mode 100644
index 0000000000..83a8a1c311
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_debug_url_browsertest.cc
@@ -0,0 +1,318 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <string>
+
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/adblock_url_loader_factory_for_test.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_config.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+using testing::_;
+using testing::HasSubstr;
+using testing::Mock;
+using testing::Return;
+using testing::StartsWith;
+
+namespace adblock {
+
+class AdblockDebugUrlTest : public InProcessBrowserTest {
+ public:
+  AdblockDebugUrlTest() {}
+  ~AdblockDebugUrlTest() override = default;
+  AdblockDebugUrlTest(const AdblockDebugUrlTest&) = delete;
+  AdblockDebugUrlTest& operator=(const AdblockDebugUrlTest&) = delete;
+
+ protected:
+  std::string ExecuteScriptAndExtractString(const std::string& js_code) const {
+    content::WebContents* web_contents =
+        browser()->tab_strip_model()->GetActiveWebContents();
+    return content::EvalJs(web_contents->GetPrimaryMainFrame(), js_code)
+        .ExtractString();
+  }
+
+  bool IsAdblockEnabled() {
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    DCHECK(adblock_configuration) << "Test expects \"adblock\" configuration";
+    return adblock_configuration->IsEnabled();
+  }
+
+  bool IsAAEnabled() {
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    DCHECK(adblock_configuration) << "Test expects \"adblock\" configuration";
+    return base::ranges::any_of(
+        adblock_configuration->GetFilterLists(),
+        [&](const auto& url) { return url == AcceptableAdsUrl(); });
+  }
+
+  std::string GetUrlForAdblockConfiguration() {
+    return std::string("http://") + kAdblockFilteringConfigurationName + "." +
+           AdblockURLLoaderFactoryForTest::kEyeoDebugDataHostName;
+  }
+
+  std::string GetUrlForListingConfigurations() {
+    return std::string("http://") +
+           AdblockURLLoaderFactoryForTest::kEyeoDebugDataHostName +
+           "/configurations";
+  }
+
+  const std::string kReadPageBodyScript =
+      "document.getElementsByTagName('body')[0].firstChild.innerHTML";
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockDebugUrlTest, TestInvalidUrls) {
+  GURL no_command1(GetUrlForAdblockConfiguration());
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), no_command1));
+  ASSERT_TRUE(base::StartsWith(
+      ExecuteScriptAndExtractString(kReadPageBodyScript), "INVALID_COMMAND"));
+
+  GURL no_command2(GetUrlForAdblockConfiguration() + "/");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), no_command2));
+  ASSERT_TRUE(base::StartsWith(
+      ExecuteScriptAndExtractString(kReadPageBodyScript), "INVALID_COMMAND"));
+
+  GURL invalid_command_url(GetUrlForAdblockConfiguration() +
+                           "/some_invalid_command");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), invalid_command_url));
+  ASSERT_TRUE(base::StartsWith(
+      ExecuteScriptAndExtractString(kReadPageBodyScript), "INVALID_COMMAND"));
+
+  GURL invalid_topic(GetUrlForAdblockConfiguration() +
+                     "/filter/add/%2Fadsponsor.");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), invalid_topic));
+  ASSERT_TRUE(base::StartsWith(
+      ExecuteScriptAndExtractString(kReadPageBodyScript), "INVALID_COMMAND"));
+
+  GURL invalid_command(GetUrlForAdblockConfiguration() +
+                       "/filters/ad/%2Fadsponsor.");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), invalid_command));
+  ASSERT_TRUE(base::StartsWith(
+      ExecuteScriptAndExtractString(kReadPageBodyScript), "INVALID_COMMAND"));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockDebugUrlTest, TestFilterCommands) {
+  GURL clear_filters_url(GetUrlForAdblockConfiguration() + "/filters/clear");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), clear_filters_url));
+  ASSERT_EQ("OK", ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  GURL list_filters_url(GetUrlForAdblockConfiguration() + "/filters/list");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), list_filters_url));
+  std::string expected_no_filters = "OK";
+  ASSERT_EQ(expected_no_filters,
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  GURL add_filters_url(GetUrlForAdblockConfiguration() +
+                       "/filters/add/%2FadsPlugin%2F%2A%0A%2Fadsponsor.");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), add_filters_url));
+  ASSERT_EQ("OK", ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), list_filters_url));
+  auto response = ExecuteScriptAndExtractString(kReadPageBodyScript);
+  ASSERT_THAT(response, StartsWith("OK\n\n"));
+  ASSERT_THAT(response, HasSubstr("adsPlugin/*"));
+  ASSERT_THAT(response, HasSubstr("adsponsor."));
+
+  GURL remove_filter_url(GetUrlForAdblockConfiguration() +
+                         "/filters/remove/%2Fadsponsor.");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), remove_filter_url));
+  ASSERT_EQ("OK", ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), list_filters_url));
+  std::string expected_one_filter = "OK\n\n/adsPlugin/*\n";
+  ASSERT_EQ(expected_one_filter,
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), clear_filters_url));
+  ASSERT_EQ("OK", ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), list_filters_url));
+  ASSERT_EQ(expected_no_filters,
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockDebugUrlTest, TestDomainCommands) {
+  GURL clear_domains_url(GetUrlForAdblockConfiguration() + "/domains/clear");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), clear_domains_url));
+  ASSERT_EQ("OK", ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  GURL list_domains_url(GetUrlForAdblockConfiguration() + "/domains/list");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), list_domains_url));
+  std::string expected_no_domains = "OK";
+  ASSERT_EQ(expected_no_domains,
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  GURL add_domain_url(GetUrlForAdblockConfiguration() +
+                      "/domains/add/example.com%0Adomain.org");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), add_domain_url));
+  ASSERT_EQ("OK", ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), list_domains_url));
+  auto response = ExecuteScriptAndExtractString(kReadPageBodyScript);
+  ASSERT_THAT(response, StartsWith("OK\n\n"));
+  ASSERT_THAT(response, HasSubstr("example.com"));
+  ASSERT_THAT(response, HasSubstr("domain.org"));
+
+  GURL remove_domain_url(GetUrlForAdblockConfiguration() +
+                         "/domains/remove/example.com");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), remove_domain_url));
+  ASSERT_EQ("OK", ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), list_domains_url));
+  std::string expected_one_domain = "OK\n\ndomain.org\n";
+  ASSERT_EQ(expected_one_domain,
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), clear_domains_url));
+  ASSERT_EQ("OK", ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), list_domains_url));
+  ASSERT_EQ(expected_no_domains,
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockDebugUrlTest, TestSubscriptionCommands) {
+  GURL clear_subscriptions_url(GetUrlForAdblockConfiguration() +
+                               "/subscriptions/clear");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), clear_subscriptions_url));
+  ASSERT_EQ("OK", ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  GURL list_subscriptions_url(GetUrlForAdblockConfiguration() +
+                              "/subscriptions/list");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), list_subscriptions_url));
+  std::string expected_no_subscriptions = "OK";
+  ASSERT_EQ(expected_no_subscriptions,
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  GURL add_subscription_url(GetUrlForAdblockConfiguration() +
+                            "/subscriptions/add/"
+                            "https%3A%2F%2Fexample.com%2Flist1.txt%0Ahttps%3A%"
+                            "2F%2Fwww.domain.org%2Flist2.txt");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), add_subscription_url));
+  ASSERT_EQ("OK", ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), list_subscriptions_url));
+  auto response = ExecuteScriptAndExtractString(kReadPageBodyScript);
+  ASSERT_THAT(response, StartsWith("OK\n\n"));
+  ASSERT_THAT(response, HasSubstr("https://example.com/list1.txt"));
+  ASSERT_THAT(response, HasSubstr("https://www.domain.org/list2.txt"));
+
+  GURL remove_subscription_url(
+      GetUrlForAdblockConfiguration() +
+      "/subscriptions/remove/https%3A%2F%2Fwww.domain.org%2Flist2.txt");
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), remove_subscription_url));
+  ASSERT_EQ("OK", ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), list_subscriptions_url));
+  std::string expected_one_subscription =
+      "OK\n\nhttps://example.com/list1.txt\n";
+  ASSERT_EQ(expected_one_subscription,
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), clear_subscriptions_url));
+  ASSERT_EQ("OK", ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), list_subscriptions_url));
+  ASSERT_EQ(expected_no_subscriptions,
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockDebugUrlTest, TestEnableConfigurationCommands) {
+  GURL enable_adblock__url(GetUrlForAdblockConfiguration() +
+                           "/configuration/enable");
+  GURL disable_adblock_url(GetUrlForAdblockConfiguration() +
+                           "/configuration/disable");
+  GURL adblock_state_url(GetUrlForAdblockConfiguration() +
+                         "/configuration/state");
+
+  ASSERT_TRUE(IsAdblockEnabled());
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), adblock_state_url));
+  ASSERT_EQ("OK\n\nenabled",
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), disable_adblock_url));
+  ASSERT_FALSE(IsAdblockEnabled());
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), adblock_state_url));
+  ASSERT_EQ("OK\n\ndisabled",
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), enable_adblock__url));
+  ASSERT_TRUE(IsAdblockEnabled());
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), adblock_state_url));
+  ASSERT_EQ("OK\n\nenabled",
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockDebugUrlTest, TestEnableAACommands) {
+  GURL enable_aa_url(GetUrlForAdblockConfiguration() + "/aa/enable");
+  GURL disable_aa_url(GetUrlForAdblockConfiguration() + "/aa/disable");
+  GURL aa_state_url(GetUrlForAdblockConfiguration() + "/aa/state");
+
+  ASSERT_TRUE(IsAAEnabled());
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), aa_state_url));
+  ASSERT_EQ("OK\n\nenabled",
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), disable_aa_url));
+  ASSERT_FALSE(IsAAEnabled());
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), aa_state_url));
+  ASSERT_EQ("OK\n\ndisabled",
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), enable_aa_url));
+  ASSERT_TRUE(IsAAEnabled());
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), aa_state_url));
+  ASSERT_EQ("OK\n\nenabled",
+            ExecuteScriptAndExtractString(kReadPageBodyScript));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockDebugUrlTest, TestListConfigurationsCommands) {
+  GURL list_configurations_url(GetUrlForListingConfigurations());
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), list_configurations_url));
+  auto response = ExecuteScriptAndExtractString(kReadPageBodyScript);
+  ASSERT_THAT(response, StartsWith("OK\n\n"));
+  ASSERT_THAT(response, HasSubstr("adblock"));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockDebugUrlTest, TestUrlsInterception) {
+  std::vector<GURL> invalid_urls = {
+      GURL{"https://adblocktest.data"}, GURL{"https://adblock.testdata"},
+      GURL{"https://adblock.test.data.eyeo"}, GURL{"https://test.data.eyeo"}};
+  std::vector<GURL> valid_urls = {GURL{"https://adblock.test.data"},
+                                  GURL{"https://ad.block.test.data"}};
+  for (const auto& url : invalid_urls) {
+    auto* rfh = ui_test_utils::NavigateToURL(browser(), url);
+    ASSERT_TRUE(rfh && rfh->IsErrorDocument());
+  }
+  for (const auto& url : valid_urls) {
+    auto* rfh = ui_test_utils::NavigateToURL(browser(), url);
+    ASSERT_TRUE(rfh && !rfh->IsErrorDocument());
+  }
+}
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_filter_list_browsertest.cc b/chrome/browser/adblock/test/adblock_filter_list_browsertest.cc
new file mode 100644
index 0000000000..14fab327fb
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_filter_list_browsertest.cc
@@ -0,0 +1,401 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "base/check.h"
+#include "base/environment.h"
+#include "base/functional/callback_forward.h"
+#include "base/run_loop.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/core/adblock_switches.h"
+#include "components/adblock/core/subscription/subscription_config.h"
+#include "components/version_info/version_info.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+
+namespace adblock {
+
+class AdblockFilterListDownloadTestBase : public InProcessBrowserTest {
+ public:
+  AdblockFilterListDownloadTestBase()
+      : https_server_(net::EmbeddedTestServer::TYPE_HTTPS) {}
+  // We need to set server and request handler asap
+  void SetUpInProcessBrowserTestFixture() override {
+    InProcessBrowserTest::SetUpInProcessBrowserTestFixture();
+    host_resolver()->AddRule("easylist-downloads.adblockplus.org", "127.0.0.1");
+    https_server_.RegisterRequestHandler(
+        base::BindRepeating(&AdblockFilterListDownloadTestBase::RequestHandler,
+                            base::Unretained(this)));
+    net::EmbeddedTestServer::ServerCertificateConfig cert_config;
+    cert_config.dns_names = {"easylist-downloads.adblockplus.org"};
+    https_server_.SetSSLConfig(cert_config);
+    ASSERT_TRUE(https_server_.Start());
+    SetFilterListServerPortForTesting(https_server_.port());
+  }
+
+  void CheckRequestParams(const net::test_server::HttpRequest& request,
+                          std::string expected_disabled_value) {
+    std::string os;
+    base::ReplaceChars(version_info::GetOSType(), base::kWhitespaceASCII, "",
+                       &os);
+    EXPECT_TRUE(request.relative_url.find("addonName=eyeo-chromium-sdk") !=
+                std::string::npos);
+    EXPECT_TRUE(request.relative_url.find("addonVersion=2.0.0") !=
+                std::string::npos);
+    EXPECT_TRUE(request.relative_url.find("platformVersion=1.0") !=
+                std::string::npos);
+    EXPECT_TRUE(request.relative_url.find("platform=" + os) !=
+                std::string::npos);
+    if (RunsOnEyeoCI()) {
+      // Those two checks below require "eyeo_application_name" and
+      // "eyeo_application_version" to be set as gn gen args.
+      EXPECT_TRUE(
+          request.relative_url.find("application=app_name_from_ci_config") !=
+          std::string::npos)
+          << "Did you set \"eyeo_application_name\" gn gen arg?";
+      EXPECT_TRUE(request.relative_url.find(
+                      "applicationVersion=app_version_from_ci_config") !=
+                  std::string::npos)
+          << "Did you set \"eyeo_application_version\" gn gen arg?";
+    }
+    EXPECT_TRUE(
+        request.relative_url.find("disabled=" + expected_disabled_value) !=
+        std::string::npos);
+  }
+
+  virtual std::unique_ptr<net::test_server::HttpResponse> RequestHandler(
+      const net::test_server::HttpRequest& request) {
+    if (request.method == net::test_server::HttpMethod::METHOD_GET &&
+        (base::StartsWith(request.relative_url, "/abp-filters-anti-cv.txt") ||
+         base::StartsWith(request.relative_url, "/easylist.txt") ||
+         base::StartsWith(request.relative_url, "/exceptionrules.txt"))) {
+      CheckRequestParams(request, "false");
+      default_lists_.insert(request.relative_url.substr(
+          1, request.relative_url.find_first_of("?") - 1));
+    }
+
+    // Unhandled requests result in the Embedded test server sending a 404. This
+    // is fine for the purpose of this test.
+    return nullptr;
+  }
+
+  void NotifyTestFinished() {
+    finish_condition_met_ = true;
+    // If the test is currently waiting for the finish condition to be met, we
+    // need to quit the run loop.
+    if (quit_closure_) {
+      quit_closure_.Run();
+    }
+  }
+
+  void RunUntilTestFinished() {
+    // If the finish condition is already met, we don't need to run the run
+    // loop.
+    if (finish_condition_met_) {
+      return;
+    }
+    // Wait until NotifyTestFinished() gets called.
+    base::RunLoop run_loop;
+    quit_closure_ = run_loop.QuitClosure();
+    std::move(run_loop).Run();
+  }
+
+  bool RunsOnEyeoCI() {
+    auto env = base::Environment::Create();
+    std::string value;
+    env->GetVar("CI_PROJECT_NAME", &value);
+    return value == "chromium-sdk";
+  }
+
+ protected:
+  net::EmbeddedTestServer https_server_;
+  std::set<std::string> default_lists_;
+  bool finish_condition_met_ = false;
+  base::RepeatingClosure quit_closure_;
+};
+
+class AdblockEnabledFilterListDownloadTest
+    : public AdblockFilterListDownloadTestBase {
+ public:
+  std::unique_ptr<net::test_server::HttpResponse> RequestHandler(
+      const net::test_server::HttpRequest& request) override {
+    auto result = AdblockFilterListDownloadTestBase::RequestHandler(request);
+    // If we get all expected requests we simply finish the test by closing
+    // the browser, otherwise test will fail with a timeout.
+    if (default_lists_.size() == 3) {
+      NotifyTestFinished();
+    }
+
+    // Unhandled requests result in the Embedded test server sending a 404.
+    return result;
+  }
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockEnabledFilterListDownloadTest,
+                       TestInitialDownloads) {
+  RunUntilTestFinished();
+}
+
+class AdblockEnabledAcceptableAdsDisabledFilterListDownloadTest
+    : public AdblockFilterListDownloadTestBase {
+ public:
+  AdblockEnabledAcceptableAdsDisabledFilterListDownloadTest() {
+    const auto testing_interval = base::Seconds(1);
+    SubscriptionServiceFactory::SetUpdateCheckAndDelayIntervalsForTesting(
+        testing_interval, testing_interval);
+  }
+
+  std::unique_ptr<net::test_server::HttpResponse> RequestHandler(
+      const net::test_server::HttpRequest& request) override {
+    // If we get expected HEAD request we simply finish the test by closing
+    // the browser, otherwise test will fail with a timeout.
+    if (request.method == net::test_server::HttpMethod::METHOD_HEAD &&
+        base::StartsWith(request.relative_url, "/exceptionrules.txt")) {
+      CheckRequestParams(request, "true");
+      NotifyTestFinished();
+    }
+
+    return nullptr;
+  }
+
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    command_line->AppendSwitch(adblock::switches::kDisableAcceptableAds);
+  }
+};
+
+IN_PROC_BROWSER_TEST_F(
+    AdblockEnabledAcceptableAdsDisabledFilterListDownloadTest,
+    TestInitialDownloads) {
+  RunUntilTestFinished();
+}
+
+enum class DisableSwitch { Adblock, Eyeo };
+
+class AdblockDisabledFilterListDownloadTest
+    : public AdblockFilterListDownloadTestBase,
+      public testing::WithParamInterface<DisableSwitch> {
+ public:
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    command_line->AppendSwitch(GetParam() == DisableSwitch::Adblock
+                                   ? adblock::switches::kDisableAdblock
+                                   : adblock::switches::kDisableEyeoFiltering);
+  }
+
+  void VerifyNoDownloads() {
+    ASSERT_EQ(0u, default_lists_.size());
+    NotifyTestFinished();
+  }
+};
+
+IN_PROC_BROWSER_TEST_P(AdblockDisabledFilterListDownloadTest,
+                       TestInitialDownloads) {
+  // This test assumes that inital downloads (for adblock enabled) will happen
+  // within 10 seconds. When tested locally it always happens within 3 seconds.
+  base::OneShotTimer timer;
+  timer.Start(
+      FROM_HERE, base::Seconds(10),
+      base::BindOnce(&AdblockDisabledFilterListDownloadTest::VerifyNoDownloads,
+                     base::Unretained(this)));
+  RunUntilTestFinished();
+}
+
+INSTANTIATE_TEST_SUITE_P(All,
+                         AdblockDisabledFilterListDownloadTest,
+                         testing::Values(DisableSwitch::Adblock,
+                                         DisableSwitch::Eyeo));
+
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+
+enum class Country {
+  Arabic,
+  Bulgaria,
+  China,
+  Czech,
+  France,
+  Germany,
+  Hungary,
+  India,
+  Indonesia,
+  Israel,
+  Italy,
+  Japan,
+  Korea,
+  Latvia,
+  Lithuania,
+  Netherlands,
+  Norway,
+  Poland,
+  Portugal,
+  Romania,
+  Russia,
+  Spain,
+  Thailand,
+  Turkey,
+  Vietnam
+};
+
+class AdblockLocaleFilterListDownloadTest
+    : public AdblockFilterListDownloadTestBase,
+      public testing::WithParamInterface<Country> {
+ public:
+  using LocaleToEasylistPath = std::pair<std::string, std::string>;
+  AdblockLocaleFilterListDownloadTest() : locale_data_(GetLocale(GetParam())) {
+    setenv("LANGUAGE", locale_data_.first.c_str(), 1);
+  }
+
+  std::unique_ptr<net::test_server::HttpResponse> RequestHandler(
+      const net::test_server::HttpRequest& request) override {
+    EXPECT_FALSE(base::StartsWith(request.relative_url, "/easylist.txt"));
+    if (request.method == net::test_server::HttpMethod::METHOD_GET &&
+        (base::StartsWith(request.relative_url, "/abp-filters-anti-cv.txt") ||
+         base::StartsWith(
+             request.relative_url,
+             GetCountrySpecificEasylistPath(locale_data_.first.substr(0, 2),
+                                            locale_data_.second)) ||
+         base::StartsWith(request.relative_url, "/exceptionrules.txt"))) {
+      CheckRequestParams(request, "false");
+      default_lists_.insert(request.relative_url.substr(
+          1, request.relative_url.find_first_of("?") - 1));
+    }
+
+    // If we get all expected requests we simply finish the test by closing
+    // the browser, otherwise test will fail with a timeout.
+    if (default_lists_.size() == 3) {
+      NotifyTestFinished();
+    }
+
+    // Unhandled requests result in the Embedded test server sending a 404.
+    return nullptr;
+  }
+
+ private:
+  LocaleToEasylistPath locale_data_;
+  LocaleToEasylistPath GetLocale(Country country) {
+    switch (country) {
+      case Country::Arabic:
+        return std::make_pair("ar_SA", "/liste_ar+liste_fr+easylist.txt");
+      case Country::Bulgaria:
+        return std::make_pair("bg_BG", "/bulgarian_list+easylist.txt");
+      case Country::China:
+        return std::make_pair("zh_CN", "/easylistchina+easylist.txt");
+      case Country::Czech:
+        return std::make_pair("cs_CZ", "/easylistczechslovak+easylist.txt");
+      case Country::France:
+        return std::make_pair("fr_FR", "/liste_fr+easylist.txt");
+      case Country::Germany:
+        return std::make_pair("de_DE", "/easylistgermany+easylist.txt");
+      case Country::Hungary:
+        return std::make_pair("hu_HU", "/hufilter+easylist.txt");
+      case Country::India:
+        return std::make_pair("ml_IN", "/indianlist+easylist.txt");
+      case Country::Indonesia:
+        return std::make_pair("id_ID", "/abpindo+easylist.txt");
+      case Country::Israel:
+        return std::make_pair("he_IL", "/israellist+easylist.txt");
+      case Country::Italy:
+        return std::make_pair("it_IT", "/easylistitaly+easylist.txt");
+      case Country::Japan:
+        return std::make_pair("ja_JP", "/japanese-filters+easylist.txt");
+      case Country::Korea:
+        return std::make_pair("ko_KR", "/koreanlist+easylist.txt");
+      case Country::Latvia:
+        return std::make_pair("lv_LV", "/latvianlist+easylist.txt");
+      case Country::Lithuania:
+        return std::make_pair("lt_LT", "/easylistlithuania+easylist.txt");
+      case Country::Netherlands:
+        return std::make_pair("nl_NL", "/easylistdutch+easylist.txt");
+      case Country::Norway:
+        return std::make_pair("no_NO",
+                              "/dandelion_sprouts_nordic_filters+easylist.txt");
+      case Country::Poland:
+        return std::make_pair("pl_PL", "/easylistpolish+easylist.txt");
+      case Country::Portugal:
+        return std::make_pair("pt_PT", "/easylistportuguese+easylist.txt");
+      case Country::Romania:
+        return std::make_pair("ro_RO", "/rolist+easylist.txt");
+      case Country::Russia:
+        return std::make_pair("ru_RU", "/ruadlist+easylist.txt");
+      case Country::Spain:
+        return std::make_pair("es_ES", "/easylistspanish+easylist.txt");
+      case Country::Thailand:
+        return std::make_pair("th_TH", "/global-filters+easylist.txt");
+      case Country::Turkey:
+        return std::make_pair("tr_TR", "/turkish-filters+easylist.txt");
+      case Country::Vietnam:
+        return std::make_pair("vi_VN", "/abpvn+easylist.txt");
+      default:
+        NOTREACHED();
+        return std::make_pair("en_US", "/easylist.txt");
+    }
+  }
+
+  std::string GetCountrySpecificEasylistPath(std::string_view language,
+                                             std::string_view expected_path) {
+    auto it = base::ranges::find_if(
+        config::GetKnownSubscriptions(), [&](const auto& config_entry) {
+          return std::find(config_entry.languages.begin(),
+                           config_entry.languages.end(),
+                           language) != config_entry.languages.end();
+        });
+    EXPECT_TRUE(it != config::GetKnownSubscriptions().end());
+    if (it != config::GetKnownSubscriptions().end()) {
+      EXPECT_EQ(expected_path, it->url.path());
+      return it->url.path();
+    }
+    return DefaultSubscriptionUrl().path();
+  }
+};
+
+IN_PROC_BROWSER_TEST_P(AdblockLocaleFilterListDownloadTest,
+                       TestInitialDownloads) {
+  RunUntilTestFinished();
+}
+
+INSTANTIATE_TEST_SUITE_P(All,
+                         AdblockLocaleFilterListDownloadTest,
+                         testing::Values(Country::Arabic,
+                                         Country::Bulgaria,
+                                         Country::China,
+                                         Country::Czech,
+                                         Country::France,
+                                         Country::Germany,
+                                         Country::Hungary,
+                                         Country::India,
+                                         Country::Indonesia,
+                                         Country::Israel,
+                                         Country::Italy,
+                                         Country::Japan,
+                                         Country::Korea,
+                                         Country::Latvia,
+                                         Country::Lithuania,
+                                         Country::Netherlands,
+                                         Country::Norway,
+                                         Country::Poland,
+                                         Country::Portugal,
+                                         Country::Romania,
+                                         Country::Russia,
+                                         Country::Spain,
+                                         Country::Thailand,
+                                         Country::Turkey,
+                                         Country::Vietnam));
+
+#endif
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_filtering_configurations_browsertest.cc b/chrome/browser/adblock/test/adblock_filtering_configurations_browsertest.cc
new file mode 100644
index 0000000000..a9cf896344
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_filtering_configurations_browsertest.cc
@@ -0,0 +1,720 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <list>
+#include "base/memory/raw_ptr.h"
+#include "base/ranges/algorithm.h"
+#include "base/run_loop.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/core/adblock_switches.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/common/adblock_prefs.h"
+#include "components/adblock/core/configuration/filtering_configuration.h"
+#include "components/adblock/core/configuration/persistent_filtering_configuration.h"
+#include "components/adblock/core/subscription/subscription_config.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "components/prefs/scoped_user_pref_update.h"
+#include "components/version_info/version_info.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "gmock/gmock.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "url/gurl.h"
+
+namespace adblock {
+
+class SubscriptionInstalledWaiter
+    : public SubscriptionService::SubscriptionObserver {
+ public:
+  explicit SubscriptionInstalledWaiter(
+      SubscriptionService* subscription_service)
+      : subscription_service_(subscription_service) {
+    subscription_service_->AddObserver(this);
+  }
+
+  ~SubscriptionInstalledWaiter() override {
+    subscription_service_->RemoveObserver(this);
+  }
+
+  void WaitUntilSubscriptionsInstalled(std::vector<GURL> subscriptions) {
+    awaited_subscriptions_ = std::move(subscriptions);
+    run_loop_.Run();
+  }
+
+  void OnSubscriptionInstalled(const GURL& subscription_url) override {
+    awaited_subscriptions_.erase(
+        base::ranges::remove(awaited_subscriptions_, subscription_url),
+        awaited_subscriptions_.end());
+    if (awaited_subscriptions_.empty()) {
+      run_loop_.Quit();
+    }
+  }
+
+ protected:
+  raw_ptr<SubscriptionService> subscription_service_;
+  base::RunLoop run_loop_;
+  std::vector<GURL> awaited_subscriptions_;
+};
+
+class AdblockFilteringConfigurationBrowserTest : public InProcessBrowserTest {
+ public:
+  void SetUpInProcessBrowserTestFixture() override {
+    InProcessBrowserTest::SetUpInProcessBrowserTestFixture();
+    host_resolver()->AddRule("*", "127.0.0.1");
+    embedded_test_server()->ServeFilesFromSourceDirectory(
+        "chrome/test/data/adblock");
+    embedded_test_server()->RegisterRequestHandler(base::BindRepeating(
+        &AdblockFilteringConfigurationBrowserTest::RequestHandler,
+        base::Unretained(this)));
+    ASSERT_TRUE(embedded_test_server()->Start());
+  }
+
+  std::unique_ptr<net::test_server::HttpResponse> RequestHandler(
+      const net::test_server::HttpRequest& request) {
+    if (request.GetURL() == AcceptableAdsUrl()) {
+      std::unique_ptr<net::test_server::BasicHttpResponse> http_response(
+          new net::test_server::BasicHttpResponse);
+      http_response->set_code(net::HTTP_OK);
+      http_response->set_content(
+          "[Adblock Plus 2.0]\n"
+          "! Checksum: X5A8vtJDBW2a9EgS9glqbg\n"
+          "! Version: 202202061935\n"
+          "! Last modified: 06 Feb 2022 19:35 UTC\n"
+          "! Expires: 1 days (update frequency)\n\n");
+      http_response->set_content_type("text/plain");
+      return std::move(http_response);
+    }
+    return nullptr;
+  }
+
+  void SetUpOnMainThread() override {
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    // Some tests remove "adblock" configuration so let's check before using.
+    if (adblock_configuration) {
+      adblock_configuration->RemoveCustomFilter(kAllowlistEverythingFilter);
+    }
+  }
+
+  GURL BlockingFilterListUrl() {
+    return embedded_test_server()->GetURL(
+        "/filterlist_that_blocks_resource.txt");
+  }
+
+  GURL ElementHidingFilterListUrl() {
+    return embedded_test_server()->GetURL(
+        "/filterlist_that_hides_resource.txt");
+  }
+
+  GURL AllowingFilterListUrl() {
+    return embedded_test_server()->GetURL(
+        "/filterlist_that_allows_resource.txt");
+  }
+
+  GURL GetPageUrl() {
+    return embedded_test_server()->GetURL("test.org", "/innermost_frame.html");
+  }
+
+  void NavigateToPage() {
+    ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetPageUrl()));
+  }
+
+  std::unique_ptr<PersistentFilteringConfiguration> MakeConfiguration(
+      std::string name) {
+    return std::make_unique<PersistentFilteringConfiguration>(
+        browser()->profile()->GetOriginalProfile()->GetPrefs(),
+        std::move(name));
+  }
+
+  void InstallFilteringConfiguration(
+      std::unique_ptr<FilteringConfiguration> configuration) {
+    SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+        ->InstallFilteringConfiguration(std::move(configuration));
+  }
+
+  void UninstallFilteringConfiguration(const std::string& configuration_name) {
+    SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+        ->UninstallFilteringConfiguration(configuration_name);
+  }
+
+  void WaitUntilSubscriptionsInstalled(std::vector<GURL> subscriptions) {
+    SubscriptionInstalledWaiter waiter(
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile()));
+    waiter.WaitUntilSubscriptionsInstalled(std::move(subscriptions));
+  }
+
+  std::string GetResourcesComputedStyle() {
+    const std::string javascript =
+        "window.getComputedStyle(document.getElementById('subresource'))."
+        "display";
+    return content::EvalJs(browser()
+                               ->tab_strip_model()
+                               ->GetActiveWebContents()
+                               ->GetPrimaryMainFrame(),
+                           javascript)
+        .ExtractString();
+  }
+
+  void ExpectResourceHidden() {
+    EXPECT_EQ("none", GetResourcesComputedStyle());
+  }
+
+  void ExpectResourceNotHidden() {
+    EXPECT_EQ("inline", GetResourcesComputedStyle());
+  }
+
+  bool IsResourceLoaded() {
+    const std::string javascript =
+        "document.getElementById('subresource').naturalHeight !== 0;";
+    return content::EvalJs(browser()
+                               ->tab_strip_model()
+                               ->GetActiveWebContents()
+                               ->GetPrimaryMainFrame(),
+                           javascript)
+        .ExtractBool();
+  }
+
+  void ExpectResourceBlocked() { EXPECT_FALSE(IsResourceLoaded()); }
+
+  void ExpectResourceNotBlocked() { EXPECT_TRUE(IsResourceLoaded()); }
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       NoBlockingByDefault) {
+  auto configuration = MakeConfiguration("config");
+  InstallFilteringConfiguration(std::move(configuration));
+
+  NavigateToPage();
+  ExpectResourceNotBlocked();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       ResourceBlockedByFilteringConfigurationsList) {
+  auto configuration = MakeConfiguration("config");
+  configuration->AddFilterList(BlockingFilterListUrl());
+
+  InstallFilteringConfiguration(std::move(configuration));
+
+  WaitUntilSubscriptionsInstalled({BlockingFilterListUrl()});
+
+  NavigateToPage();
+  ExpectResourceBlocked();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       ResourceHiddenByFilteringConfigurationsList) {
+  auto configuration = MakeConfiguration("config");
+  configuration->AddFilterList(ElementHidingFilterListUrl());
+
+  InstallFilteringConfiguration(std::move(configuration));
+
+  WaitUntilSubscriptionsInstalled({ElementHidingFilterListUrl()});
+
+  NavigateToPage();
+  ExpectResourceHidden();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       ResourceAllowedByFilteringConfigurationsList) {
+  auto configuration = MakeConfiguration("config");
+  configuration->AddFilterList(BlockingFilterListUrl());
+  configuration->AddFilterList(ElementHidingFilterListUrl());
+  configuration->AddFilterList(AllowingFilterListUrl());
+
+  InstallFilteringConfiguration(std::move(configuration));
+
+  WaitUntilSubscriptionsInstalled({BlockingFilterListUrl(),
+                                   AllowingFilterListUrl(),
+                                   ElementHidingFilterListUrl()});
+
+  NavigateToPage();
+  ExpectResourceNotBlocked();
+  ExpectResourceNotHidden();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       BlockingTakesPrecedenceBetweenConfigurations) {
+  auto blocking_configuration = MakeConfiguration("blocking");
+  blocking_configuration->AddFilterList(BlockingFilterListUrl());
+
+  auto allowing_configuration = MakeConfiguration("allowing");
+  allowing_configuration->AddFilterList(AllowingFilterListUrl());
+
+  InstallFilteringConfiguration(std::move(blocking_configuration));
+  InstallFilteringConfiguration(std::move(allowing_configuration));
+
+  WaitUntilSubscriptionsInstalled(
+      {BlockingFilterListUrl(), AllowingFilterListUrl()});
+
+  NavigateToPage();
+  ExpectResourceBlocked();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       ElementBlockedByCustomFilter) {
+  auto configuration = MakeConfiguration("config");
+  configuration->AddCustomFilter("*resource.png");
+
+  InstallFilteringConfiguration(std::move(configuration));
+
+  NavigateToPage();
+  ExpectResourceBlocked();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       ElementAllowedByCustomFilter) {
+  auto configuration = MakeConfiguration("config");
+  configuration->AddCustomFilter("*resource.png");
+  configuration->AddCustomFilter("@@*resource.png");
+
+  InstallFilteringConfiguration(std::move(configuration));
+
+  NavigateToPage();
+  ExpectResourceNotBlocked();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       ElementAllowedByAllowedDomain) {
+  auto configuration = MakeConfiguration("config");
+  configuration->AddCustomFilter("*resource.png");
+  configuration->AddAllowedDomain(GetPageUrl().host());
+
+  InstallFilteringConfiguration(std::move(configuration));
+
+  NavigateToPage();
+  ExpectResourceNotBlocked();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       PRE_CustomFiltersPersist) {
+  auto configuration = MakeConfiguration("persistent");
+  // This custom filter will survive browser restart.
+  configuration->AddCustomFilter("*resource.png");
+  InstallFilteringConfiguration(std::move(configuration));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       CustomFiltersPersist) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration = base::ranges::find(configurations, "persistent",
+                                          &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration != configurations.end());
+  EXPECT_THAT((*configuration)->GetCustomFilters(),
+              testing::UnorderedElementsAre("*resource.png"));
+
+  NavigateToPage();
+  ExpectResourceBlocked();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       DisabledConfigurationDoesNotBlock) {
+  auto configuration = MakeConfiguration("config");
+  configuration->AddCustomFilter("*resource.png");
+  configuration->SetEnabled(false);
+
+  InstallFilteringConfiguration(std::move(configuration));
+
+  NavigateToPage();
+  ExpectResourceNotBlocked();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       ConfigurationCanBeUsedAfterInstalling) {
+  auto configuration = MakeConfiguration("config");
+  auto* configuration_ptr = configuration.get();
+
+  InstallFilteringConfiguration(std::move(configuration));
+
+  configuration_ptr->AddCustomFilter("*resource.png");
+
+  NavigateToPage();
+  ExpectResourceBlocked();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       ConfigurationCanBeDisabledAfterInstalling) {
+  auto configuration = MakeConfiguration("config");
+  auto* configuration_ptr = configuration.get();
+
+  InstallFilteringConfiguration(std::move(configuration));
+
+  configuration_ptr->AddCustomFilter("*resource.png");
+  configuration_ptr->SetEnabled(false);
+
+  NavigateToPage();
+  ExpectResourceNotBlocked();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       SubscriptionsDownloadedAfterConfigurationEnabled) {
+  auto configuration = MakeConfiguration("config");
+  configuration->SetEnabled(false);
+  configuration->AddFilterList(BlockingFilterListUrl());
+  configuration->AddFilterList(ElementHidingFilterListUrl());
+  configuration->AddFilterList(AllowingFilterListUrl());
+  auto* configuration_ptr = configuration.get();
+
+  InstallFilteringConfiguration(std::move(configuration));
+
+  configuration_ptr->SetEnabled(true);
+
+  WaitUntilSubscriptionsInstalled({BlockingFilterListUrl(),
+                                   AllowingFilterListUrl(),
+                                   ElementHidingFilterListUrl()});
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       PRE_DownloadedSubscriptionsPersistOnDisk) {
+  auto configuration = MakeConfiguration("config");
+  // This filter list setting will survive browser restart.
+  configuration->AddFilterList(BlockingFilterListUrl());
+
+  InstallFilteringConfiguration(std::move(configuration));
+
+  // This downloaded subscription won't need to be re-downloaded after restart.
+  WaitUntilSubscriptionsInstalled({BlockingFilterListUrl()});
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       DownloadedSubscriptionsPersistOnDisk) {
+  NavigateToPage();
+  ExpectResourceBlocked();
+}
+
+// 1st run: create.
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       PRE_PRE_CreateThenRemoveCustomConfiguration) {
+  auto configuration = MakeConfiguration("persistent");
+  InstallFilteringConfiguration(std::move(configuration));
+}
+
+// 2nd run: remove.
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       PRE_CreateThenRemoveCustomConfiguration) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration = base::ranges::find(configurations, "persistent",
+                                          &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration != configurations.end());
+  UninstallFilteringConfiguration("persistent");
+  configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  configuration = base::ranges::find(configurations, "persistent",
+                                     &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration == configurations.end());
+}
+
+// 3rd run: verify not present.
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       CreateThenRemoveCustomConfiguration) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration = base::ranges::find(configurations, "persistent",
+                                          &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration == configurations.end());
+}
+
+// 1st run: confirm "adblock" configuration is created and contains expected
+// default settings, then change some settings and verify in the next run.
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       PRE_PRE_RemoveAdblockConfiguration) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration =
+      base::ranges::find(configurations, kAdblockFilteringConfigurationName,
+                         &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration != configurations.end());
+  ASSERT_TRUE((*configuration)->IsEnabled());
+  auto domains = (*configuration)->GetAllowedDomains();
+  ASSERT_TRUE(domains.empty());
+  auto subscriptions = (*configuration)->GetFilterLists();
+  ASSERT_EQ(3u, subscriptions.size());
+  ASSERT_TRUE(std::find(subscriptions.begin(), subscriptions.end(),
+                        AcceptableAdsUrl()) != subscriptions.end());
+  ASSERT_TRUE(std::find(subscriptions.begin(), subscriptions.end(),
+                        DefaultSubscriptionUrl()) != subscriptions.end());
+  ASSERT_TRUE(std::find(subscriptions.begin(), subscriptions.end(),
+                        AntiCVUrl()) != subscriptions.end());
+  // Change some settings and check in 2nd run.
+  (*configuration)->AddAllowedDomain("example.com");
+  (*configuration)->SetEnabled(false);
+}
+
+// 2nd run: make sure that previously changed settings are persisted, then
+// remove "adblock" configuration.
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       PRE_RemoveAdblockConfiguration) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration =
+      base::ranges::find(configurations, kAdblockFilteringConfigurationName,
+                         &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration != configurations.end());
+
+  // Check previously changed settings.
+  ASSERT_FALSE((*configuration)->IsEnabled());
+  auto domains = (*configuration)->GetAllowedDomains();
+  ASSERT_EQ(1u, domains.size());
+  ASSERT_EQ("example.com", (*configuration)->GetAllowedDomains().front());
+
+  UninstallFilteringConfiguration(kAdblockFilteringConfigurationName);
+  configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  configuration =
+      base::ranges::find(configurations, kAdblockFilteringConfigurationName,
+                         &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration == configurations.end());
+}
+
+// 3rd run: verify "adblock" configuration is not present.
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       RemoveAdblockConfiguration) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration =
+      base::ranges::find(configurations, kAdblockFilteringConfigurationName,
+                         &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration == configurations.end());
+}
+
+// 1st run: set legacy prefs and verify migration in the next run.
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       PRE_MigrateSettings) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration =
+      base::ranges::find(configurations, kAdblockFilteringConfigurationName,
+                         &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration != configurations.end());
+  auto* prefs = browser()->profile()->GetOriginalProfile()->GetPrefs();
+  ASSERT_FALSE(
+      prefs->GetBoolean(common::prefs::kInstallFirstStartSubscriptions));
+  ASSERT_TRUE(
+      prefs->GetList(common::prefs::kAdblockCustomSubscriptionsLegacy).empty());
+  auto subscriptions = (*configuration)->GetFilterLists();
+  ASSERT_TRUE(std::find(subscriptions.begin(), subscriptions.end(),
+                        GURL{"https://custom.bar"}) == subscriptions.end());
+  ASSERT_TRUE(std::find(subscriptions.begin(), subscriptions.end(),
+                        GURL{"https://default.bar"}) == subscriptions.end());
+  ASSERT_TRUE(std::find(subscriptions.begin(), subscriptions.end(),
+                        AcceptableAdsUrl()) != subscriptions.end());
+  ASSERT_TRUE((*configuration)->GetAllowedDomains().empty());
+  ASSERT_TRUE((*configuration)->GetCustomFilters().empty());
+  ASSERT_TRUE((*configuration)->IsEnabled());
+
+  // Now set legacy prefs.
+  {
+    ScopedListPrefUpdate update(
+        prefs, common::prefs::kAdblockCustomSubscriptionsLegacy);
+    update->Append("https://custom.bar");
+  }
+  {
+    ScopedListPrefUpdate update(prefs,
+                                common::prefs::kAdblockSubscriptionsLegacy);
+    update->Append("https://default.bar");
+  }
+  {
+    ScopedListPrefUpdate update(prefs,
+                                common::prefs::kAdblockAllowedDomainsLegacy);
+    update->Append("example.com");
+  }
+  {
+    ScopedListPrefUpdate update(prefs,
+                                common::prefs::kAdblockCustomFiltersLegacy);
+    update->Append("test.com$script");
+  }
+  prefs->SetBoolean(common::prefs::kEnableAdblockLegacy, false);
+  prefs->SetBoolean(common::prefs::kEnableAcceptableAdsLegacy, false);
+
+  // Remove "adblock" configuration to trigger migration in the next run.
+  UninstallFilteringConfiguration(kAdblockFilteringConfigurationName);
+}
+
+// 2nd run: check migrated settings.
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       MigrateSettings) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration =
+      base::ranges::find(configurations, kAdblockFilteringConfigurationName,
+                         &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration != configurations.end());
+  auto* prefs = browser()->profile()->GetOriginalProfile()->GetPrefs();
+  ASSERT_FALSE(
+      prefs->GetBoolean(common::prefs::kInstallFirstStartSubscriptions));
+  ASSERT_FALSE((*configuration)->IsEnabled());
+  auto subscriptions = (*configuration)->GetFilterLists();
+  ASSERT_TRUE(std::find(subscriptions.begin(), subscriptions.end(),
+                        GURL{"https://custom.bar"}) != subscriptions.end());
+  ASSERT_TRUE(std::find(subscriptions.begin(), subscriptions.end(),
+                        GURL{"https://default.bar"}) != subscriptions.end());
+  ASSERT_TRUE(std::find(subscriptions.begin(), subscriptions.end(),
+                        AcceptableAdsUrl()) == subscriptions.end());
+  auto domains = (*configuration)->GetAllowedDomains();
+  ASSERT_TRUE(std::find(domains.begin(), domains.end(), "example.com") !=
+              domains.end());
+  auto filters = (*configuration)->GetCustomFilters();
+  ASSERT_TRUE(std::find(filters.begin(), filters.end(), "test.com$script") !=
+              filters.end());
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       PRE_PersistDisabledAAState) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration =
+      base::ranges::find(configurations, kAdblockFilteringConfigurationName,
+                         &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration != configurations.end());
+  auto subscriptions = (*configuration)->GetFilterLists();
+  ASSERT_TRUE(std::find(subscriptions.begin(), subscriptions.end(),
+                        AcceptableAdsUrl()) != subscriptions.end());
+  (*configuration)->RemoveFilterList(AcceptableAdsUrl());
+  subscriptions = (*configuration)->GetFilterLists();
+  ASSERT_FALSE(std::find(subscriptions.begin(), subscriptions.end(),
+                         AcceptableAdsUrl()) != subscriptions.end());
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       PersistDisabledAAState) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration =
+      base::ranges::find(configurations, kAdblockFilteringConfigurationName,
+                         &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration != configurations.end());
+  auto subscriptions = (*configuration)->GetFilterLists();
+  ASSERT_FALSE(std::find(subscriptions.begin(), subscriptions.end(),
+                         AcceptableAdsUrl()) != subscriptions.end());
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       PRE_PersistEnabledAAState) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration =
+      base::ranges::find(configurations, kAdblockFilteringConfigurationName,
+                         &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration != configurations.end());
+  auto subscriptions = (*configuration)->GetFilterLists();
+  ASSERT_TRUE(std::find(subscriptions.begin(), subscriptions.end(),
+                        AcceptableAdsUrl()) != subscriptions.end());
+  (*configuration)->RemoveFilterList(AcceptableAdsUrl());
+  subscriptions = (*configuration)->GetFilterLists();
+  ASSERT_FALSE(std::find(subscriptions.begin(), subscriptions.end(),
+                         AcceptableAdsUrl()) != subscriptions.end());
+  (*configuration)->AddFilterList(AcceptableAdsUrl());
+  subscriptions = (*configuration)->GetFilterLists();
+  ASSERT_TRUE(std::find(subscriptions.begin(), subscriptions.end(),
+                        AcceptableAdsUrl()) != subscriptions.end());
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationBrowserTest,
+                       PersistEnabledAAState) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration =
+      base::ranges::find(configurations, kAdblockFilteringConfigurationName,
+                         &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration != configurations.end());
+  auto subscriptions = (*configuration)->GetFilterLists();
+  ASSERT_TRUE(std::find(subscriptions.begin(), subscriptions.end(),
+                        AcceptableAdsUrl()) != subscriptions.end());
+}
+
+class AdblockFilteringConfigurationDisableSwitchBrowserTest
+    : public AdblockFilteringConfigurationBrowserTest {
+ public:
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    if (base::StartsWith(
+            ::testing::UnitTest::GetInstance()->current_test_info()->name(),
+            "PRE_CreateConfigAndConfirmEnableStateAfterReset")) {
+      command_line->AppendSwitch(adblock::switches::kDisableEyeoFiltering);
+    }
+  }
+};
+
+// 1st run: create configuration and make sure it is enabled by default.
+IN_PROC_BROWSER_TEST_F(
+    AdblockFilteringConfigurationDisableSwitchBrowserTest,
+    PRE_PRE_PRE_CreateConfigAndConfirmEnableStateAfterReset) {
+  auto configuration = MakeConfiguration("persistent");
+  ASSERT_TRUE(configuration->IsEnabled());
+  InstallFilteringConfiguration(std::move(configuration));
+}
+
+// 2nd run: make sure configuration is enabled after restart.
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationDisableSwitchBrowserTest,
+                       PRE_PRE_CreateConfigAndConfirmEnableStateAfterReset) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration = base::ranges::find(configurations, "persistent",
+                                          &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration != configurations.end());
+  ASSERT_TRUE((*configuration)->IsEnabled());
+}
+
+// 3rd run: after adding "--disable-eyeo-filtering" make sure configuration is
+// disabled.
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationDisableSwitchBrowserTest,
+                       PRE_CreateConfigAndConfirmEnableStateAfterReset) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration = base::ranges::find(configurations, "persistent",
+                                          &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration != configurations.end());
+  ASSERT_FALSE((*configuration)->IsEnabled());
+}
+
+// 4th run: without "--disable-eyeo-filtering" make sure configuration is still
+// disabled.
+IN_PROC_BROWSER_TEST_F(AdblockFilteringConfigurationDisableSwitchBrowserTest,
+                       CreateConfigAndConfirmEnableStateAfterReset) {
+  auto configurations =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+          ->GetInstalledFilteringConfigurations();
+  auto configuration = base::ranges::find(configurations, "persistent",
+                                          &FilteringConfiguration::GetName);
+  ASSERT_TRUE(configuration != configurations.end());
+  ASSERT_FALSE((*configuration)->IsEnabled());
+}
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_frame_hierarchy_builder_browsertest.cc b/chrome/browser/adblock/test/adblock_frame_hierarchy_builder_browsertest.cc
new file mode 100644
index 0000000000..461fa93842
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_frame_hierarchy_builder_browsertest.cc
@@ -0,0 +1,475 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <vector>
+
+#include "base/ranges/algorithm.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ssl/https_upgrades_util.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/adblock_filter_match.h"
+#include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/frame_hierarchy_builder.h"
+#include "components/adblock/content/browser/resource_classification_runner.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "components/blocked_content/popup_blocker_tab_helper.h"
+#include "components/embedder_support/switches.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace adblock {
+
+namespace {
+class TabAddedRemovedObserver : public TabStripModelObserver {
+ public:
+  explicit TabAddedRemovedObserver(TabStripModel* tab_strip_model) {
+    tab_strip_model->AddObserver(this);
+  }
+
+  void OnTabStripModelChanged(
+      TabStripModel* tab_strip_model,
+      const TabStripModelChange& change,
+      const TabStripSelectionChange& selection) override {
+    if (change.type() == TabStripModelChange::kInserted) {
+      inserted_ = true;
+      return;
+    }
+    if (change.type() == TabStripModelChange::kRemoved) {
+      EXPECT_TRUE(inserted_);
+      removed_ = true;
+      loop_.Quit();
+      return;
+    }
+    NOTREACHED();
+  }
+
+  void Wait() {
+    if (inserted_ && removed_) {
+      return;
+    }
+    loop_.Run();
+  }
+
+ private:
+  bool inserted_ = false;
+  bool removed_ = false;
+  base::RunLoop loop_;
+};
+}  // namespace
+
+class ResourceClassificationRunnerObserver
+    : public ResourceClassificationRunner::Observer {
+ public:
+  ~ResourceClassificationRunnerObserver() override {
+    VerifyNoUnexpectedNotifications();
+  }
+  // ResourceClassificationRunner::Observer:
+  void OnRequestMatched(const GURL& url,
+                        FilterMatchResult match_result,
+                        const std::vector<GURL>& parent_frame_urls,
+                        ContentType content_type,
+                        content::RenderFrameHost* render_frame_host,
+                        const GURL& subscription,
+                        const std::string& configuration_name) override {
+    if (match_result == FilterMatchResult::kAllowRule) {
+      allowed_ads_notifications.push_back(url);
+    } else {
+      blocked_ads_notifications.push_back(url);
+    }
+  }
+
+  void OnPageAllowed(const GURL& url,
+                     content::RenderFrameHost* render_frame_host,
+                     const GURL& subscription,
+                     const std::string& configuration_name) override {
+    allowed_pages_notifications.push_back(url);
+  }
+
+  void OnPopupMatched(const GURL& url,
+                      FilterMatchResult match_result,
+                      const GURL& opener_url,
+                      content::RenderFrameHost* render_frame_host,
+                      const GURL& subscription,
+                      const std::string& configuration_name) override {
+    auto& list = (match_result == FilterMatchResult::kBlockRule
+                      ? blocked_popups_notifications
+                      : allowed_popups_notifications);
+    auto it = std::find(list.begin(), list.end(), url.ExtractFileName());
+    ASSERT_FALSE(it == list.end())
+        << "Path " << url.ExtractFileName() << " not on list";
+    list.erase(it);
+    if (popup_notifications_run_loop_ && allowed_popups_notifications.empty() &&
+        blocked_popups_notifications.empty()) {
+      popup_notifications_run_loop_->Quit();
+    }
+  }
+
+  void VerifyNotificationSent(base::StringPiece path, std::vector<GURL>& list) {
+    auto it = base::ranges::find(list, path, &GURL::ExtractFileName);
+    ASSERT_FALSE(it == list.end()) << "Path " << path << " not on list";
+    // Remove expected notifications so that we can verify there are no
+    // unexpected notifications left by the end of each test.
+    list.erase(it);
+  }
+
+  void VerifyNoUnexpectedNotifications() {
+    EXPECT_TRUE(blocked_ads_notifications.empty());
+    EXPECT_TRUE(allowed_ads_notifications.empty());
+    EXPECT_TRUE(blocked_popups_notifications.empty());
+    EXPECT_TRUE(allowed_popups_notifications.empty());
+    EXPECT_TRUE(allowed_pages_notifications.empty());
+  }
+
+  std::vector<GURL> blocked_ads_notifications;
+  std::vector<GURL> allowed_ads_notifications;
+  std::vector<GURL> allowed_pages_notifications;
+  std::vector<std::string> blocked_popups_notifications;
+  std::vector<std::string> allowed_popups_notifications;
+  std::unique_ptr<base::RunLoop> popup_notifications_run_loop_;
+};
+
+// Simulated setup:
+// http://outer.com/outermost_frame.html
+//   has an iframe: http://middle.com/middle_frame.html
+//     has an iframe: http://inner.com/innermost_frame.html
+//       has a subresource http://inner.com/resource.png
+//
+// All of these files are in chrome/test/data/adblock. Cross-domain distribution
+// is simulated via SetupCrossSiteRedirector.
+// innermost_frame.html reports whether resource.png is visible via
+// window.top.postMessage to outermost_frame.html, which stores a global
+// subresource_visible JS variable.
+class AdblockFrameHierarchyBrowserTest : public InProcessBrowserTest {
+ public:
+  void SetUpOnMainThread() override {
+    InProcessBrowserTest::SetUpOnMainThread();
+    host_resolver()->AddRule("*", "127.0.0.1");
+    embedded_test_server()->ServeFilesFromSourceDirectory(
+        "chrome/test/data/adblock");
+    content::SetupCrossSiteRedirector(embedded_test_server());
+    AllowHttpForHostnamesForTesting({"outer.com", "inner.com", "middle.com"},
+                                    browser()->profile()->GetPrefs());
+    ASSERT_TRUE(embedded_test_server()->Start());
+    auto* classification_runner =
+        ResourceClassificationRunnerFactory::GetForBrowserContext(
+            browser()->profile());
+    classification_runner->AddObserver(&observer);
+  }
+
+  void TearDownOnMainThread() override {
+    auto* classification_runner =
+        ResourceClassificationRunnerFactory::GetForBrowserContext(
+            browser()->profile());
+    classification_runner->RemoveObserver(&observer);
+    InProcessBrowserTest::TearDownOnMainThread();
+  }
+
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    command_line->AppendSwitch(embedder_support::kDisablePopupBlocking);
+  }
+
+  void SetFilters(std::vector<std::string> filters) {
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    adblock_configuration->RemoveCustomFilter(kAllowlistEverythingFilter);
+    for (auto& filter : filters) {
+      adblock_configuration->AddCustomFilter(filter);
+    }
+  }
+
+  void NavigateToOutermostFrame() {
+    ASSERT_TRUE(ui_test_utils::NavigateToURL(
+        browser(), embedded_test_server()->GetURL(
+                       "/cross-site/outer.com/outermost_frame.html")));
+  }
+
+  void NavigateToOutermostFrameWithAboutBlank() {
+    ASSERT_TRUE(ui_test_utils::NavigateToURL(
+        browser(),
+        embedded_test_server()->GetURL(
+            "/cross-site/outer.com/outermost_frame_with_about_blank.html")));
+  }
+
+  void NavigateToPopupParentFrameAndWaitForNotifications() {
+    observer.popup_notifications_run_loop_ = std::make_unique<base::RunLoop>();
+    ASSERT_TRUE(ui_test_utils::NavigateToURL(
+        browser(), embedded_test_server()->GetURL(
+                       "/cross-site/outer.com/popup_parent.html")));
+    if (!(observer.allowed_popups_notifications.empty() &&
+          observer.blocked_popups_notifications.empty())) {
+      observer.popup_notifications_run_loop_->Run();
+    }
+  }
+
+  void VerifyTargetResourceShown(bool expected_visible,
+                                 const char* visibility_param) {
+    // Since in one test we dynamically load (write) `about:blank` iframe after
+    // parent page is loaded, we need to have some wait & poll mechanism to wait
+    // until such a frame (and its resources) is completely loaded by JS.
+    std::string script = base::StringPrintf(
+        R"(
+      (async () => {
+        let count = 10;
+        let visibility_param = '%s';
+        function waitFor(condition) {
+          const poll = resolve => {
+            if(condition() || !count--) resolve();
+            else setTimeout(_ => poll(resolve), 200);
+          }
+          return new Promise(poll);
+        }
+        // Waits up to 2 seconds
+        await waitFor(_ => window.subresource_visibility[visibility_param] === %s);
+        return window.subresource_visibility[visibility_param] === false;
+     })()
+     )",
+        visibility_param, expected_visible ? "false" : "true");
+    EXPECT_EQ(
+        expected_visible,
+        content::EvalJs(browser()->tab_strip_model()->GetActiveWebContents(),
+                        script));
+  }
+
+  void VerifyTargetResourceBlockingStatus(bool expected_visible) {
+    VerifyTargetResourceShown(expected_visible, "is_blocked");
+  }
+
+  void VerifyTargetResourceHidingStatus(bool expected_visible) {
+    VerifyTargetResourceShown(expected_visible, "is_hidden");
+  }
+
+  int NumberOfOpenTabs() { return browser()->tab_strip_model()->GetTabCount(); }
+
+  ResourceClassificationRunnerObserver observer;
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest,
+                       SubresourceShownWithNoFilters) {
+  SetFilters({});
+  NavigateToOutermostFrame();
+  VerifyTargetResourceBlockingStatus(true);
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest, SubresourceBlocked) {
+  SetFilters({"/resource.png"});
+  NavigateToOutermostFrame();
+  VerifyTargetResourceBlockingStatus(false);
+  observer.VerifyNotificationSent("resource.png",
+                                  observer.blocked_ads_notifications);
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest,
+                       SubresourceAllowedViaInnerFrame) {
+  SetFilters({"/resource.png", "@@||inner.com^$document"});
+  NavigateToOutermostFrame();
+  VerifyTargetResourceBlockingStatus(true);
+  observer.VerifyNotificationSent("resource.png",
+                                  observer.allowed_ads_notifications);
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest,
+                       SubresourceAllowedViaMiddleFrame) {
+  SetFilters({"/resource.png", "@@||middle.com^$document"});
+  NavigateToOutermostFrame();
+  VerifyTargetResourceBlockingStatus(true);
+  observer.VerifyNotificationSent("resource.png",
+                                  observer.allowed_ads_notifications);
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest,
+                       SubresourceAllowedViaOutermostFrame) {
+  SetFilters({"/resource.png", "@@||outer.com^$document"});
+  NavigateToOutermostFrame();
+  VerifyTargetResourceBlockingStatus(true);
+  observer.VerifyNotificationSent("resource.png",
+                                  observer.allowed_ads_notifications);
+  observer.VerifyNotificationSent("outermost_frame.html",
+                                  observer.allowed_pages_notifications);
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest,
+                       SubresourceBlockedWhenInvalidAllowRule) {
+  SetFilters({"/resource.png", "@@||bogus.com^$document"});
+  NavigateToOutermostFrame();
+  VerifyTargetResourceBlockingStatus(false);
+  observer.VerifyNotificationSent("resource.png",
+                                  observer.blocked_ads_notifications);
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest,
+                       DISABLED_PopupHandledByChromiumWithoutFilters) {
+  // Without any popup-specific filters, blocking popups is handed over to
+  // Chromium, which has it's own heuristics that are not based on filters.
+  SetFilters({});
+  NavigateToPopupParentFrameAndWaitForNotifications();
+  // The popup was not opened:
+  EXPECT_EQ(1, NumberOfOpenTabs());
+  // Because Chromium's built-in popup blocker stopped it:
+  EXPECT_EQ(1u, blocked_content::PopupBlockerTabHelper::FromWebContents(
+                    browser()->tab_strip_model()->GetActiveWebContents())
+                    ->GetBlockedPopupsCount());
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest, PopupBlockedByFilter) {
+  SetFilters({"http://inner.com*/popup.html$popup"});
+  observer.blocked_popups_notifications.emplace_back("popup.html");
+  TabAddedRemovedObserver observer(browser()->tab_strip_model());
+  NavigateToPopupParentFrameAndWaitForNotifications();
+  observer.Wait();
+  EXPECT_EQ(1, NumberOfOpenTabs());
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest, PopupAllowedByFilter) {
+  SetFilters({"http://inner.com*/popup.html$popup",
+              "@@http://inner.com*/popup.html$popup"});
+  observer.allowed_popups_notifications.emplace_back("popup.html");
+  NavigateToPopupParentFrameAndWaitForNotifications();
+  // Popup was allowed to open in a new tab
+  EXPECT_EQ(2, NumberOfOpenTabs());
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest,
+                       PopupAllowedByDomainSpecificFilter) {
+  // The frame that wants to open the popup is hosted on middle.com.
+  // The $popup allow rule applies to that frame.
+  SetFilters({"http://inner.com*/popup.html$popup",
+              "@@http://inner.com*/popup.html$popup,domain=middle.com"});
+  observer.allowed_popups_notifications.emplace_back("popup.html");
+  NavigateToPopupParentFrameAndWaitForNotifications();
+  // Popup was allowed to open in a new tab
+  EXPECT_EQ(2, NumberOfOpenTabs());
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest,
+                       PopupNotAllowedByDomainSpecificFilter) {
+  // The frame that wants to open the popup is hosted on middle.com.
+  // The $popup allow rule does not apply because it is specific to outer.com.
+  // outer.com is not the frame that is opening the popup.
+  SetFilters({"http://inner.com*/popup.html$popup",
+              "@@http://inner.com*/popup.html$popup,domain=outer.com"});
+  observer.blocked_popups_notifications.emplace_back("popup.html");
+  TabAddedRemovedObserver observer(browser()->tab_strip_model());
+  NavigateToPopupParentFrameAndWaitForNotifications();
+  observer.Wait();
+  EXPECT_EQ(1, NumberOfOpenTabs());
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest,
+                       PopupAllowedByParentDocument) {
+  // The outermost frame has a blanket allowing rule of $document type.
+  SetFilters({"http://inner.com*/popup.html$popup",
+              "@@||outer.com^$document,domain=outer.com"});
+  observer.allowed_popups_notifications.emplace_back("popup.html");
+  NavigateToPopupParentFrameAndWaitForNotifications();
+  // Popup was allowed to open in a new tab
+  EXPECT_EQ(2, NumberOfOpenTabs());
+  observer.VerifyNotificationSent("popup_parent.html",
+                                  observer.allowed_pages_notifications);
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest,
+                       PopupAllowedByIntermediateParentDocument) {
+  // The middle frame has a blanket allowing rule of $document type.
+  SetFilters({"http://inner.com*/popup.html$popup",
+              "@@||middle.com^$document,domain=outer.com"});
+  observer.allowed_popups_notifications.emplace_back("popup.html");
+  NavigateToPopupParentFrameAndWaitForNotifications();
+  // Popup was allowed to open in a new tab
+  EXPECT_EQ(2, NumberOfOpenTabs());
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest, BlankFrameHiding) {
+  SetFilters({"##.about_blank_div"});
+  NavigateToOutermostFrameWithAboutBlank();
+  std::string script = R"(
+    function writeIframe() {
+      let frameDocument = document.getElementById("about_blank").contentWindow.document;
+      frameDocument.open("text/html");
+      frameDocument.write(`
+        <html>
+          <body>
+            <div class="about_blank_div">
+              <iframe id='middle_frame' src='/cross-site/middle.com/middle_frame.html' width='400'></iframe>
+            </div>
+          </body>
+        </html>`);
+      frameDocument.close();
+    }
+    if (document.readyState == "complete") {
+      writeIframe();
+    } else {
+      document.getElementById("about_blank").addEventListener("load", writeIframe);
+    }
+  )";
+  EXPECT_TRUE(content::ExecJs(
+      browser()->tab_strip_model()->GetActiveWebContents(), script));
+  VerifyTargetResourceHidingStatus(false);
+  SetFilters({"@@^eyeo=true$document"});
+  NavigateToOutermostFrameWithAboutBlank();
+  EXPECT_TRUE(content::ExecJs(
+      browser()->tab_strip_model()->GetActiveWebContents(), script));
+  VerifyTargetResourceHidingStatus(true);
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockFrameHierarchyBrowserTest, BlankFrameBlocking) {
+  SetFilters({"/resource.png"});
+  NavigateToOutermostFrameWithAboutBlank();
+  std::string script = R"(
+    function writeIframe() {
+      let frameDocument = document.getElementById("about_blank").contentWindow.document;
+      frameDocument.open("text/html");
+      frameDocument.write(`
+        <html>
+          <body>
+            <iframe id='middle_frame' src='/cross-site/middle.com/middle_frame.html' width='400'></iframe>
+          </body>
+        </html>`);
+      frameDocument.close();
+    }
+    if (document.readyState == "complete") {
+      writeIframe();
+    } else {
+      document.getElementById("about_blank").addEventListener("load", writeIframe);
+    }
+  )";
+  EXPECT_TRUE(content::ExecJs(
+      browser()->tab_strip_model()->GetActiveWebContents(), script));
+  VerifyTargetResourceBlockingStatus(false);
+  observer.VerifyNotificationSent("resource.png",
+                                  observer.blocked_ads_notifications);
+  SetFilters({"@@^eyeo=true$document"});
+  NavigateToOutermostFrameWithAboutBlank();
+  EXPECT_TRUE(content::ExecJs(
+      browser()->tab_strip_model()->GetActiveWebContents(), script));
+  VerifyTargetResourceBlockingStatus(true);
+  observer.VerifyNotificationSent("resource.png",
+                                  observer.allowed_ads_notifications);
+}
+
+// More tests can be added / parametrized, e.g.:
+// - elemhide blocking filters (in conjunction with $elemhide allow rules)
+// - $subdocument-based allow rules
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_ml_browsertest.cc b/chrome/browser/adblock/test/adblock_ml_browsertest.cc
new file mode 100644
index 0000000000..aa1fd45446
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_ml_browsertest.cc
@@ -0,0 +1,77 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/extensions/component_loader.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/core/features.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+class AdblockMlApiTest : public InProcessBrowserTest {
+ protected:
+  base::Value Execute(std::string js) {
+    base::RunLoop loop;
+    base::Value result;
+    browser()
+        ->tab_strip_model()
+        ->GetActiveWebContents()
+        ->GetPrimaryMainFrame()
+        ->ExecuteJavaScriptInIsolatedWorld(
+            base::UTF8ToUTF16(js),
+            base::BindOnce(
+                [](base::RunLoop* loop, base::Value* result, base::Value arg) {
+                  *result = std::move(arg);
+                  loop->Quit();
+                },
+                &loop, &result),
+            content::ISOLATED_WORLD_ID_ADBLOCK);
+    loop.Run();
+    return result;
+  }
+
+  void SetUpInProcessBrowserTestFixture() override {
+    scoped_feature_list_.InitAndEnableFeature(adblock::kEyeoMlServiceFeature);
+  }
+
+  void SetUp() override {
+    extensions::ComponentLoader::EnableBackgroundExtensionsForTesting();
+    InProcessBrowserTest::SetUp();
+  }
+
+  base::test::ScopedFeatureList scoped_feature_list_;
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockMlApiTest, BasicMessaging) {
+  Execute(
+      R"(
+      chrome.runtime.sendMessage(
+        "phhdcbipnceblbigdhhoahagpfdblied", {type: "ML:test"}, result => {
+          if (result.type === "ML:test" && result.error === 2) { document.title = 'success'; }
+          else { console.log(JSON.stringify(result)); document.title = 'failure'; }
+        });
+      )");
+  content::TitleWatcher title_watcher(
+      browser()->tab_strip_model()->GetActiveWebContents(), u"success");
+  title_watcher.AlsoWaitForTitle(u"failure");
+  std::u16string result = title_watcher.WaitAndGetTitle();
+  EXPECT_EQ(u"success", result);
+}
diff --git a/chrome/browser/adblock/test/adblock_multiple_tabs_browsertest.cc b/chrome/browser/adblock/test/adblock_multiple_tabs_browsertest.cc
new file mode 100644
index 0000000000..8eb822cc73
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_multiple_tabs_browsertest.cc
@@ -0,0 +1,168 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_list.h"
+#include "chrome/browser/ui/tabs/recent_tabs_sub_menu_model.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/resource_classification_runner.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "components/sessions/content/session_tab_helper.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+
+namespace adblock {
+
+class AdblockMultipleTabsBrowserTest
+    : public InProcessBrowserTest,
+      public ResourceClassificationRunner::Observer {
+ public:
+  void SetUpOnMainThread() override {
+    host_resolver()->AddRule(kTestDomain, "127.0.0.1");
+    embedded_test_server()->ServeFilesFromSourceDirectory(
+        "chrome/test/data/adblock");
+    ASSERT_TRUE(embedded_test_server()->Start());
+    ResourceClassificationRunnerFactory::GetForBrowserContext(
+        browser()->profile())
+        ->AddObserver(this);
+    SetFilters({"blocked.png", "allowed.png", "@@allowed.png"});
+  }
+
+  void TearDownInProcessBrowserTestFixture() override {
+    ASSERT_EQ(kTabsCount, static_cast<int>(tabs_with_blocked_resource_.size()));
+    ASSERT_EQ(kTabsCount, static_cast<int>(tabs_with_allowed_resource_.size()));
+  }
+
+  void SetFilters(std::vector<std::string> filters) {
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    adblock_configuration->RemoveCustomFilter(kAllowlistEverythingFilter);
+    for (auto& filter : filters) {
+      adblock_configuration->AddCustomFilter(filter);
+    }
+  }
+
+  void RestoreTabs(Browser* browser) {
+    content::DOMMessageQueue queue;
+    RecentTabsSubMenuModel menu(nullptr, browser);
+    menu.ExecuteCommand(menu.GetFirstRecentTabsCommandId(), 0);
+    for (int i = 0; i < kTabsCount; ++i) {
+      std::string message;
+      EXPECT_TRUE(queue.WaitForMessage(&message));
+      EXPECT_EQ("\"READY\"", message);
+    }
+  }
+
+  // ResourceClassificationRunner::Observer:
+  void OnRequestMatched(const GURL& url,
+                        FilterMatchResult match_result,
+                        const std::vector<GURL>& parent_frame_urls,
+                        ContentType content_type,
+                        content::RenderFrameHost* render_frame_host,
+                        const GURL& subscription,
+                        const std::string& configuration_name) override {
+    const content::WebContents* wc =
+        content::WebContents::FromRenderFrameHost(render_frame_host);
+    if (match_result == FilterMatchResult::kBlockRule &&
+        url.path() == "/blocked.png") {
+      tabs_with_blocked_resource_.insert(
+          sessions::SessionTabHelper::IdForTab(wc).id());
+    } else if (match_result == FilterMatchResult::kAllowRule &&
+               url.path() == "/allowed.png") {
+      tabs_with_allowed_resource_.insert(
+          sessions::SessionTabHelper::IdForTab(wc).id());
+    }
+  }
+
+  void OnPageAllowed(const GURL& url,
+                     content::RenderFrameHost* render_frame_host,
+                     const GURL& subscription,
+                     const std::string& configuration_name) override {}
+
+  void OnPopupMatched(const GURL& url,
+                      FilterMatchResult match_result,
+                      const GURL& opener_url,
+                      content::RenderFrameHost* render_frame_host,
+                      const GURL& subscription,
+                      const std::string& configuration_name) override {}
+
+ protected:
+  const int kTabsCount = 4;
+  const char* kTestDomain = "example.com";
+  std::set<int> tabs_with_blocked_resource_;
+  std::set<int> tabs_with_allowed_resource_;
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockMultipleTabsBrowserTest, PRE_OpenManyTabs) {
+  // Load page in already opened tab
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(),
+      embedded_test_server()->GetURL(kTestDomain, "/tab-restore.html")));
+  // Open more tabs
+  for (int i = 0; i < kTabsCount - 1; ++i) {
+    ASSERT_TRUE(ui_test_utils::NavigateToURLWithDisposition(
+        browser(),
+        embedded_test_server()->GetURL(kTestDomain, "/tab-restore.html"),
+        WindowOpenDisposition::NEW_FOREGROUND_TAB,
+        ui_test_utils::BROWSER_TEST_WAIT_FOR_LOAD_STOP));
+  }
+  EXPECT_EQ(kTabsCount, browser()->tab_strip_model()->count());
+  EXPECT_EQ(kTabsCount, static_cast<int>(tabs_with_blocked_resource_.size()));
+  EXPECT_EQ(kTabsCount, static_cast<int>(tabs_with_allowed_resource_.size()));
+
+  // Open a new browser instance
+  ui_test_utils::NavigateToURLWithDisposition(
+      browser(), GURL(url::kAboutBlankURL), WindowOpenDisposition::NEW_WINDOW,
+      ui_test_utils::BROWSER_TEST_WAIT_FOR_BROWSER);
+  BrowserList* active_browser_list = BrowserList::GetInstance();
+  EXPECT_EQ(2u, active_browser_list->size());
+
+  // Close the 1st browser and clear tabs test data
+  CloseBrowserSynchronously(browser());
+  EXPECT_EQ(1u, active_browser_list->size());
+  tabs_with_blocked_resource_.clear();
+  tabs_with_allowed_resource_.clear();
+
+  Browser* browser = active_browser_list->get(0);
+  // Restore tabs from1 st browser instance (already closed) in 2nd instance
+  RestoreTabs(browser);
+}
+
+// TODO(atokodi): Enable this test once it works on OSX. It currently does not
+// work because of an upstream bug. See DPD-2528
+#if BUILDFLAG(IS_MAC)
+#define MAYBE_OpenManyTabs DISABLED_OpenManyTabs
+#else
+#define MAYBE_OpenManyTabs OpenManyTabs
+#endif
+
+IN_PROC_BROWSER_TEST_F(AdblockMultipleTabsBrowserTest, MAYBE_OpenManyTabs) {
+  ASSERT_EQ(0u, tabs_with_blocked_resource_.size());
+  ASSERT_EQ(0u, tabs_with_allowed_resource_.size());
+  // Restore tabs from previous session (previous test)
+  RestoreTabs(browser());
+}
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_non_ascii_browsertest.cc b/chrome/browser/adblock/test/adblock_non_ascii_browsertest.cc
new file mode 100644
index 0000000000..43de135b1b
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_non_ascii_browsertest.cc
@@ -0,0 +1,78 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace adblock {
+
+class AdblockNonASCIIBrowserTest : public InProcessBrowserTest {
+ public:
+  void SetUpOnMainThread() override {
+    host_resolver()->AddRule("xn----dtbfdbwspgnceulm.xn--p1ai", "127.0.0.1");
+    embedded_test_server()->ServeFilesFromSourceDirectory(
+        "chrome/test/data/adblock");
+    content::SetupCrossSiteRedirector(embedded_test_server());
+    ASSERT_TRUE(embedded_test_server()->Start());
+  }
+
+  void SetFilters(std::vector<std::string> filters) {
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    adblock_configuration->RemoveCustomFilter(kAllowlistEverythingFilter);
+    for (auto& filter : filters) {
+      adblock_configuration->AddCustomFilter(filter);
+    }
+  }
+
+  std::string ExecuteScriptAndExtractString(const std::string& js_code) const {
+    content::WebContents* web_contents =
+        browser()->tab_strip_model()->GetActiveWebContents();
+    return content::EvalJs(web_contents->GetPrimaryMainFrame(), js_code)
+        .ExtractString();
+  }
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockNonASCIIBrowserTest, BlockNonASCII) {
+  static constexpr char kCheckVisibility[] =
+      R"(getComputedStyle(document.getElementsByClassName("")[0]).display)";
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(),
+      embedded_test_server()->GetURL("-.", "/non-ascii.html")));
+  EXPECT_EQ("block", ExecuteScriptAndExtractString(kCheckVisibility));
+
+  SetFilters({"xn----dtbfdbwspgnceulm.xn--p1ai##."});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(
+      browser(),
+      embedded_test_server()->GetURL("-.", "/non-ascii.html")));
+
+  EXPECT_EQ("none", ExecuteScriptAndExtractString(kCheckVisibility));
+}
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_popup_browsertest.cc b/chrome/browser/adblock/test/adblock_popup_browsertest.cc
new file mode 100644
index 0000000000..7b3c1f9509
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_popup_browsertest.cc
@@ -0,0 +1,462 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "base/run_loop.h"
+#include "chrome/app/chrome_command_ids.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/renderer_context_menu/render_view_context_menu_browsertest_util.h"
+#include "chrome/browser/renderer_context_menu/render_view_context_menu_test_util.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_list.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/resource_classification_runner.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "gmock/gmock.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "url/gurl.h"
+
+namespace adblock {
+
+namespace {
+class TabAddedRemovedObserver : public TabStripModelObserver {
+ public:
+  explicit TabAddedRemovedObserver(TabStripModel* tab_strip_model) {
+    tab_strip_model->AddObserver(this);
+  }
+
+  void OnTabStripModelChanged(
+      TabStripModel* tab_strip_model,
+      const TabStripModelChange& change,
+      const TabStripSelectionChange& selection) override {
+    if (change.type() == TabStripModelChange::kInserted) {
+      inserted_ = true;
+      return;
+    }
+    if (change.type() == TabStripModelChange::kRemoved) {
+      EXPECT_TRUE(inserted_);
+      removed_ = true;
+      loop_.Quit();
+      return;
+    }
+    NOTREACHED();
+  }
+
+  void Wait() {
+    if (inserted_ && removed_) {
+      return;
+    }
+    loop_.Run();
+  }
+
+ private:
+  bool inserted_ = false;
+  bool removed_ = false;
+  base::RunLoop loop_;
+};
+
+enum class Redirection { ClientSide, ServerSide };
+
+}  // namespace
+
+class AdblockPopupBrowserTest
+    : public InProcessBrowserTest,
+      public ResourceClassificationRunner::Observer,
+      public testing::WithParamInterface<Redirection> {
+ public:
+  void SetUpOnMainThread() override {
+    InProcessBrowserTest::SetUpOnMainThread();
+    host_resolver()->AddRule("*", "127.0.0.1");
+    embedded_test_server()->RegisterRequestHandler(base::BindRepeating(
+        &AdblockPopupBrowserTest::RequestHandler, base::Unretained(this)));
+    ASSERT_TRUE(embedded_test_server()->Start());
+    ResourceClassificationRunnerFactory::GetForBrowserContext(
+        browser()->profile())
+        ->AddObserver(this);
+  }
+
+  void TearDownOnMainThread() override {
+    VerifyNoUnexpectedNotifications();
+    ResourceClassificationRunnerFactory::GetForBrowserContext(
+        browser()->profile())
+        ->RemoveObserver(this);
+    InProcessBrowserTest::TearDownOnMainThread();
+  }
+
+  void VerifyNoUnexpectedNotifications() {
+    EXPECT_TRUE(blocked_popups_notifications_expectations_.empty());
+    EXPECT_TRUE(allowed_popups_notifications_expectations_.empty());
+  }
+
+  bool IsServerSideRedirection() {
+    return GetParam() == Redirection::ServerSide;
+  }
+
+  virtual std::unique_ptr<net::test_server::HttpResponse> RequestHandler(
+      const net::test_server::HttpRequest& request) {
+    if (base::StartsWith("/main_page.html", request.relative_url)) {
+      static constexpr char kPopupFrameParent[] =
+          R"(
+        <!DOCTYPE html>
+        <html>
+          <head></head>
+          <body>
+            <iframe id='popup_frame' src='/popup_frame.html'></iframe>
+          </body>
+        </html>)";
+      std::unique_ptr<net::test_server::BasicHttpResponse> http_response(
+          new net::test_server::BasicHttpResponse);
+      http_response->set_code(net::HTTP_OK);
+      http_response->set_content(kPopupFrameParent);
+      http_response->set_content_type("text/html");
+      return std::move(http_response);
+    }
+    if (base::StartsWith("/popup_frame.html", request.relative_url)) {
+      static constexpr char kPopupFrame[] =
+          R"(
+        <!DOCTYPE html>
+        <html>
+          <head>
+            <script>
+              "use strict";
+              let redirect_popup_url = "/popup_will_redirect.html";
+              function scriptPopupTab() {
+                window.open(redirect_popup_url);
+              }
+              function scriptPopupWindow() {
+                window.open(redirect_popup_url, "some-popup", "resizable");
+              }
+            </script>
+          </head>
+          <body>
+            <a href="/popup_will_redirect.html" target="_blank" id="popup_link_will_redirect">Trigger link based popup with redirect</a>
+            <a href="/popup_no_redirect.html" target="_blank" id="popup_link_no_redirect">Trigger link based popup without redirect</a>
+            <a href="#script-based-popup-tab" onclick="scriptPopupTab();" id="popup_script_tab">Trigger script based popup (tab) with redirect</a>
+            <a href="#script-based-popup-window" onclick="scriptPopupWindow();" id="popup_script_window">Trigger script based popup (window) with redirect</a>
+          </body>
+        </html>)";
+      std::unique_ptr<net::test_server::BasicHttpResponse> http_response(
+          new net::test_server::BasicHttpResponse);
+      http_response->set_code(net::HTTP_OK);
+      http_response->set_content(kPopupFrame);
+      http_response->set_content_type("text/html");
+      return std::move(http_response);
+    }
+    if (base::StartsWith("/popup_no_redirect.html", request.relative_url) ||
+        base::StartsWith("/popup_redirected.html", request.relative_url)) {
+      std::unique_ptr<net::test_server::BasicHttpResponse> http_response(
+          new net::test_server::BasicHttpResponse);
+      http_response->set_code(net::HTTP_OK);
+      http_response->set_content("");
+      http_response->set_content_type("text/html");
+      return std::move(http_response);
+    }
+    if (base::StartsWith("/popup_will_redirect.html", request.relative_url)) {
+      static constexpr char kClientSideRedirectingPopup[] =
+          R"(
+        <!DOCTYPE html>
+        <html>
+          <head>
+            <script type="text/javascript">
+              window.location = "/popup_redirected.html"
+            </script>
+          </head>
+          <body></body>
+        </html>)";
+      std::unique_ptr<net::test_server::BasicHttpResponse> http_response(
+          new net::test_server::BasicHttpResponse);
+      if (IsServerSideRedirection()) {
+        http_response->set_code(net::HTTP_MOVED_PERMANENTLY);
+        http_response->AddCustomHeader(
+            "Location", GetPageUrl("/popup_redirected.html").spec());
+      } else {
+        http_response->set_code(net::HTTP_OK);
+        http_response->set_content(kClientSideRedirectingPopup);
+        http_response->set_content_type("text/html");
+      }
+      return std::move(http_response);
+    }
+    return nullptr;
+  }
+
+  void SetFilters(std::vector<std::string> filters) {
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    adblock_configuration->RemoveCustomFilter(kAllowlistEverythingFilter);
+    for (auto& filter : filters) {
+      adblock_configuration->AddCustomFilter(filter);
+    }
+  }
+
+  void TriggerPopup(const std::string& popup_id) {
+    std::string script = base::StringPrintf(
+        R"(
+      let doc = document.querySelector('iframe[id="popup_frame"]').contentWindow.document;
+      let element = doc.getElementById('%s');
+      element.click();
+    )",
+        popup_id.c_str());
+    EXPECT_TRUE(content::ExecJs(
+        browser()->tab_strip_model()->GetActiveWebContents(), script));
+  }
+
+  GURL GetPageUrl(const std::string& page) {
+    return embedded_test_server()->GetURL("popup_frame.org", page);
+  }
+
+  void NavigateToPage() {
+    ASSERT_TRUE(
+        ui_test_utils::NavigateToURL(browser(), GetPageUrl("/main_page.html")));
+  }
+
+  void WaitForTabToLoad() {
+    content::WebContents* popup =
+        browser()->tab_strip_model()->GetActiveWebContents();
+    WaitForLoadStop(popup);
+  }
+
+  void SetupNotificationsWaiter(base::RunLoop* run_loop) {
+    run_loop_ = run_loop;
+  }
+
+  // ResourceClassificationRunner::Observer:
+  void OnRequestMatched(const GURL& url,
+                        FilterMatchResult match_result,
+                        const std::vector<GURL>& parent_frame_urls,
+                        ContentType content_type,
+                        content::RenderFrameHost* render_frame_host,
+                        const GURL& subscription,
+                        const std::string& configuration_name) override {}
+
+  void OnPageAllowed(const GURL& url,
+                     content::RenderFrameHost* render_frame_host,
+                     const GURL& subscription,
+                     const std::string& configuration_name) override {}
+
+  void OnPopupMatched(const GURL& url,
+                      FilterMatchResult match_result,
+                      const GURL& opener_url,
+                      content::RenderFrameHost* render_frame_host,
+                      const GURL& subscription,
+                      const std::string& configuration_name) override {
+    auto& list = (match_result == FilterMatchResult::kBlockRule
+                      ? blocked_popups_notifications_expectations_
+                      : allowed_popups_notifications_expectations_);
+    auto it = std::find(list.begin(), list.end(), url.ExtractFileName());
+    ASSERT_FALSE(it == list.end())
+        << "Path " << url.ExtractFileName() << " not on list";
+    list.erase(it);
+    if (run_loop_ && allowed_popups_notifications_expectations_.empty() &&
+        blocked_popups_notifications_expectations_.empty()) {
+      run_loop_->Quit();
+    }
+  }
+
+  std::vector<std::string> allowed_popups_notifications_expectations_;
+  std::vector<std::string> blocked_popups_notifications_expectations_;
+  raw_ptr<base::RunLoop> run_loop_ = nullptr;
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockPopupBrowserTest, PopupLinkBlocked) {
+  SetFilters({"popup_no_redirect.html^$popup"});
+  blocked_popups_notifications_expectations_.emplace_back(
+      "popup_no_redirect.html");
+  NavigateToPage();
+  TabAddedRemovedObserver observer(browser()->tab_strip_model());
+  TriggerPopup("popup_link_no_redirect");
+  observer.Wait();
+  EXPECT_EQ(1, browser()->tab_strip_model()->count());
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPopupBrowserTest,
+                       PopupScriptTabWithRedirectBlocked) {
+  SetFilters({"popup_redirected.html^$popup"});
+  blocked_popups_notifications_expectations_.emplace_back(
+      "popup_redirected.html");
+  NavigateToPage();
+  TabAddedRemovedObserver observer(browser()->tab_strip_model());
+  TriggerPopup("popup_script_tab");
+  observer.Wait();
+  EXPECT_EQ(1, browser()->tab_strip_model()->count());
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPopupBrowserTest,
+                       PopupScriptWindowWithRedirectBlocked) {
+  SetFilters({"popup_redirected.html^$popup"});
+  blocked_popups_notifications_expectations_.emplace_back(
+      "popup_redirected.html");
+  NavigateToPage();
+  TriggerPopup("popup_script_window");
+  // Wait for 2nd browser to get closed (new window popup blocked)
+  EXPECT_EQ(2u, BrowserList::GetInstance()->size());
+  ui_test_utils::WaitForBrowserToClose(BrowserList::GetInstance()->get(1));
+  EXPECT_EQ(1u, BrowserList::GetInstance()->size());
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPopupBrowserTest, PopupLinkWithRedirectBlocked) {
+  SetFilters({"popup_redirected.html^$popup"});
+  blocked_popups_notifications_expectations_.emplace_back(
+      "popup_redirected.html");
+  NavigateToPage();
+  TabAddedRemovedObserver observer(browser()->tab_strip_model());
+  TriggerPopup("popup_link_will_redirect");
+  observer.Wait();
+  EXPECT_EQ(1, browser()->tab_strip_model()->count());
+}
+
+IN_PROC_BROWSER_TEST_P(
+    AdblockPopupBrowserTest,
+    PopupScriptTabWithRedirectAllowedByIntermediateParentDocument) {
+  SetFilters({"popup_redirected.html^$popup", "@@/popup_frame.html^$document"});
+  allowed_popups_notifications_expectations_.emplace_back(
+      "popup_redirected.html");
+  NavigateToPage();
+  ui_test_utils::TabAddedWaiter waiter(browser());
+  TriggerPopup("popup_script_tab");
+  waiter.Wait();
+  WaitForTabToLoad();
+  EXPECT_EQ(2, browser()->tab_strip_model()->count());
+}
+
+IN_PROC_BROWSER_TEST_P(
+    AdblockPopupBrowserTest,
+    PopupScriptWindowWithRedirectAllowedByIntermediateParentDocument) {
+  SetFilters({"popup_redirected.html^$popup", "@@/popup_frame.html^$document"});
+  allowed_popups_notifications_expectations_.emplace_back(
+      "popup_redirected.html");
+  NavigateToPage();
+  base::RunLoop run_loop;
+  SetupNotificationsWaiter(&run_loop);
+  TriggerPopup("popup_script_window");
+  run_loop.Run();
+  EXPECT_EQ(2u, BrowserList::GetInstance()->size());
+}
+
+IN_PROC_BROWSER_TEST_P(
+    AdblockPopupBrowserTest,
+    PopupLinkWithRedirectAllowedByIntermediateParentDocument) {
+  SetFilters({"popup_redirected.html^$popup", "@@/popup_frame.html^$document"});
+  allowed_popups_notifications_expectations_.emplace_back(
+      "popup_redirected.html");
+  NavigateToPage();
+  ui_test_utils::TabAddedWaiter waiter(browser());
+  TriggerPopup("popup_link_will_redirect");
+  waiter.Wait();
+  WaitForTabToLoad();
+  EXPECT_EQ(2, browser()->tab_strip_model()->count());
+  ;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPopupBrowserTest,
+                       PopupScriptTabWithRedirectAllowedByParentDocument) {
+  SetFilters({"popup_redirected.html^$popup", "@@/main_page.html^$document"});
+  allowed_popups_notifications_expectations_.emplace_back(
+      "popup_redirected.html");
+  NavigateToPage();
+  ui_test_utils::TabAddedWaiter waiter(browser());
+  TriggerPopup("popup_script_tab");
+  waiter.Wait();
+  WaitForTabToLoad();
+  EXPECT_EQ(2, browser()->tab_strip_model()->count());
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPopupBrowserTest,
+                       PopupScriptWindowWithRedirectAllowedByParentDocument) {
+  SetFilters({"popup_redirected.html^$popup", "@@/main_page.html^$document"});
+  allowed_popups_notifications_expectations_.emplace_back(
+      "popup_redirected.html");
+  NavigateToPage();
+  base::RunLoop run_loop;
+  SetupNotificationsWaiter(&run_loop);
+  TriggerPopup("popup_script_window");
+  run_loop.Run();
+  EXPECT_EQ(2u, BrowserList::GetInstance()->size());
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPopupBrowserTest,
+                       PopupLinkWithRedirectAllowedByParentDocument) {
+  SetFilters({"popup_redirected.html^$popup", "@@/main_page.html^$document"});
+  allowed_popups_notifications_expectations_.emplace_back(
+      "popup_redirected.html");
+  NavigateToPage();
+  ui_test_utils::TabAddedWaiter waiter(browser());
+  TriggerPopup("popup_link_will_redirect");
+  waiter.Wait();
+  WaitForTabToLoad();
+  EXPECT_EQ(2, browser()->tab_strip_model()->count());
+}
+
+// Make sure that we correctly recognize and apply blocking of
+// redirected popups only for real popups.
+IN_PROC_BROWSER_TEST_P(AdblockPopupBrowserTest,
+                       LinkOpenedByContextMenuInNewTabNotBlocked) {
+  SetFilters({"popup_redirected.html^$popup"});
+  ContextMenuNotificationObserver menu_observer(
+      IDC_CONTENT_CONTEXT_OPENLINKNEWTAB);
+  ui_test_utils::AllBrowserTabAddedWaiter add_tab;
+
+  std::string script = base::StringPrintf(
+      "data:text/html,<a href='%s'>link</a>",
+      GetPageUrl("/popup_will_redirect.html").spec().c_str());
+  // Go to a page with a link
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GURL(script)));
+
+  // Opens a link in a new tab via a "real" context menu.
+  blink::WebMouseEvent mouse_event(
+      blink::WebInputEvent::Type::kMouseDown,
+      blink::WebInputEvent::kNoModifiers,
+      blink::WebInputEvent::GetStaticTimeStampForTests());
+  mouse_event.button = blink::WebMouseEvent::Button::kRight;
+  mouse_event.SetPositionInWidget(15, 15);
+  content::WebContents* tab =
+      browser()->tab_strip_model()->GetActiveWebContents();
+  gfx::Rect offset = tab->GetContainerBounds();
+  mouse_event.SetPositionInScreen(15 + offset.x(), 15 + offset.y());
+  mouse_event.click_count = 1;
+  tab->GetPrimaryMainFrame()
+      ->GetRenderViewHost()
+      ->GetWidget()
+      ->ForwardMouseEvent(mouse_event);
+  mouse_event.SetType(blink::WebInputEvent::Type::kMouseUp);
+  tab->GetPrimaryMainFrame()
+      ->GetRenderViewHost()
+      ->GetWidget()
+      ->ForwardMouseEvent(mouse_event);
+
+  // The menu_observer will select "Open in new tab", wait for the new tab to
+  // be added.
+  tab = add_tab.Wait();
+  EXPECT_TRUE(content::WaitForLoadStop(tab));
+
+  // Verify that it's the correct tab.
+  EXPECT_EQ(GetPageUrl("/popup_redirected.html"), tab->GetLastCommittedURL());
+}
+
+INSTANTIATE_TEST_SUITE_P(All,
+                         AdblockPopupBrowserTest,
+                         testing::Values(Redirection::ClientSide,
+                                         Redirection::ServerSide));
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_service_workers_browsertest.cc b/chrome/browser/adblock/test/adblock_service_workers_browsertest.cc
new file mode 100644
index 0000000000..f1530462af
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_service_workers_browsertest.cc
@@ -0,0 +1,157 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <list>
+
+#include "base/memory/raw_ptr.h"
+#include "base/ranges/algorithm.h"
+#include "base/run_loop.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/configuration/filtering_configuration.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "components/prefs/scoped_user_pref_update.h"
+#include "components/version_info/version_info.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "gmock/gmock.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "url/gurl.h"
+
+namespace adblock {
+
+class AdblockServiceWorkersBrowserTest : public InProcessBrowserTest {
+ public:
+  void SetUpInProcessBrowserTestFixture() override {
+    InProcessBrowserTest::SetUpInProcessBrowserTestFixture();
+    host_resolver()->AddRule("*", "127.0.0.1");
+    // Note, fetch_from_service_worker.js and fetch_from_service_worker.html are
+    // also available in content/test/data. This could be a content_browsertest,
+    // probably.
+    embedded_test_server()->ServeFilesFromSourceDirectory("chrome/test/data");
+    embedded_test_server()->RegisterRequestHandler(
+        base::BindRepeating(&AdblockServiceWorkersBrowserTest::RequestHandler,
+                            base::Unretained(this)));
+    ASSERT_TRUE(embedded_test_server()->Start());
+  }
+
+  std::unique_ptr<net::test_server::HttpResponse> RequestHandler(
+      const net::test_server::HttpRequest& request) {
+    if (request.relative_url == "/requested_path") {
+      std::unique_ptr<net::test_server::BasicHttpResponse> http_response(
+          new net::test_server::BasicHttpResponse);
+      http_response->set_code(net::HTTP_OK);
+      http_response->set_content("fetch completed");
+      http_response->set_content_type("text/plain");
+      return std::move(http_response);
+    }
+    return nullptr;
+  }
+
+  void SetUpOnMainThread() override {
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    adblock_configuration->RemoveCustomFilter(kAllowlistEverythingFilter);
+  }
+
+  void AddFilter(std::string filter) {
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    adblock_configuration->AddCustomFilter(filter);
+  }
+
+  void AddAllowedDomain(std::string domain) {
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    adblock_configuration->AddAllowedDomain(domain);
+  }
+
+  GURL GetPageUrl() {
+    // Reusing an existing test page to avoid creating a new one.
+    // This page exposes a setup() function to register a service worker
+    // and a fetch_from_service_worker() function to perform a network fetch
+    // by sending an internal message to the service worker.
+    return embedded_test_server()->GetURL(
+        "/service_worker/fetch_from_service_worker.html");
+  }
+
+  content::WebContents* active_webcontents() {
+    return browser()->tab_strip_model()->GetActiveWebContents();
+  }
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockServiceWorkersBrowserTest, NoBlockingByDefault) {
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetPageUrl()));
+  EXPECT_EQ("ready", content::EvalJs(active_webcontents(), "setup();"));
+
+  // "fetch completed" is returned by our RequestHandler.
+  EXPECT_EQ("fetch completed",
+            content::EvalJs(active_webcontents(),
+                            "fetch_from_service_worker('/requested_path');"));
+}
+
+// TODO(mpawlowski) enable after blocking is implemented.
+IN_PROC_BROWSER_TEST_F(AdblockServiceWorkersBrowserTest,
+                       DISABLED_ResourceBlockedByCustomFilter) {
+  AddFilter("*requested_path");
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetPageUrl()));
+  EXPECT_EQ("ready", content::EvalJs(active_webcontents(), "setup();"));
+
+  // "bad response" is returned by
+  // chrome/test/data/service_worker/fetch_from_service_worker.js when the fetch
+  // fails. This indicates RequestHandler was never called, the request was
+  // blocked.
+  EXPECT_EQ("bad response",
+            content::EvalJs(active_webcontents(),
+                            "fetch_from_service_worker('/requested_path');"));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockServiceWorkersBrowserTest,
+                       ResourceAllowedByResourceSpecificAllowingRule) {
+  AddFilter("*resource.png");
+  AddFilter("@@*resource.png");
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetPageUrl()));
+  EXPECT_EQ("ready", content::EvalJs(active_webcontents(), "setup();"));
+  EXPECT_EQ("fetch completed",
+            content::EvalJs(active_webcontents(),
+                            "fetch_from_service_worker('/requested_path');"));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockServiceWorkersBrowserTest,
+                       ResourceAllowedByOrigin) {
+  AddFilter("*resource.png");
+  AddAllowedDomain(GetPageUrl().host());
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetPageUrl()));
+  EXPECT_EQ("ready", content::EvalJs(active_webcontents(), "setup();"));
+  EXPECT_EQ("fetch completed",
+            content::EvalJs(active_webcontents(),
+                            "fetch_from_service_worker('/requested_path');"));
+}
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_snippets_browsertest.cc b/chrome/browser/adblock/test/adblock_snippets_browsertest.cc
new file mode 100644
index 0000000000..369719a9a1
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_snippets_browsertest.cc
@@ -0,0 +1,80 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <vector>
+
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace adblock {
+
+class AdblockSnippetsBrowserTest : public InProcessBrowserTest {
+ public:
+  void SetUpOnMainThread() override {
+    InProcessBrowserTest::SetUpOnMainThread();
+    host_resolver()->AddRule("*", "127.0.0.1");
+    embedded_test_server()->ServeFilesFromSourceDirectory(
+        "chrome/test/data/adblock");
+    ASSERT_TRUE(embedded_test_server()->Start());
+  }
+
+  void SetFilters(std::vector<std::string> filters) {
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    adblock_configuration->RemoveCustomFilter(kAllowlistEverythingFilter);
+    for (auto& filter : filters) {
+      adblock_configuration->AddCustomFilter(filter);
+    }
+  }
+
+  GURL GetUrl(const std::string& path) {
+    return embedded_test_server()->GetURL("example.org", path);
+  }
+
+  void VerifyTargetVisibility(bool is_hidden, const std::string& id) {
+    std::string is_invisible_js =
+        "getComputedStyle(document.getElementById('{{node id}}')).display == "
+        "'none'";
+    base::ReplaceSubstringsAfterOffset(&is_invisible_js, 0, "{{node id}}", id);
+    EXPECT_EQ(
+        is_hidden,
+        content::EvalJs(browser()->tab_strip_model()->GetActiveWebContents(),
+                        is_invisible_js));
+  }
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockSnippetsBrowserTest, VerifyXpath3) {
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl("/xpath3.html")));
+  VerifyTargetVisibility(false, "xpath3-target");
+  SetFilters(
+      {"example.org#$#hide-if-matches-xpath3 //*[@id=\"xpath3-target\"]"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl("/xpath3.html")));
+  VerifyTargetVisibility(true, "xpath3-target");
+}
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_subscription_service_browsertest.cc b/chrome/browser/adblock/test/adblock_subscription_service_browsertest.cc
new file mode 100644
index 0000000000..29f6ca4dde
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_subscription_service_browsertest.cc
@@ -0,0 +1,226 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "base/files/file_util.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/ranges/algorithm.h"
+#include "base/run_loop.h"
+#include "base/strings/string_split.h"
+#include "base/test/bind.h"
+#include "base/threading/thread_restrictions.h"
+#include "base/time/time.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/factories/subscription_persistent_metadata_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_config.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "components/version_info/version_info.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/http/http_request_headers.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+
+namespace adblock {
+
+class AdblockSubscriptionServiceBrowserTest
+    : public InProcessBrowserTest,
+      public SubscriptionService::SubscriptionObserver {
+ public:
+  AdblockSubscriptionServiceBrowserTest() {
+    SubscriptionServiceFactory::SetUpdateCheckAndDelayIntervalsForTesting(
+        base::Seconds(1), base::Seconds(1));
+  }
+  void SetUpOnMainThread() override {
+    InProcessBrowserTest::SetUpOnMainThread();
+    https_server_ = std::make_unique<net::EmbeddedTestServer>(
+        net::EmbeddedTestServer::TYPE_HTTPS);
+    https_server_->SetSSLConfig(net::EmbeddedTestServer::CERT_OK);
+  }
+
+  bool RequestHeadersContainAcceptLanguage(
+      const net::test_server::HttpRequest& request) {
+    const auto accept_language_it =
+        request.headers.find(net::HttpRequestHeaders::kAcceptLanguage);
+    return accept_language_it != request.headers.end() &&
+           !accept_language_it->second.empty();
+  }
+
+  bool RequestHeadersContainAcceptEncodingBrotli(
+      const net::test_server::HttpRequest& request) {
+    const auto accept_encoding_it =
+        request.headers.find(net::HttpRequestHeaders::kAcceptEncoding);
+    if (accept_encoding_it == request.headers.end()) {
+      return false;
+    }
+    const auto split_encodings =
+        base::SplitString(accept_encoding_it->second, ",",
+                          base::WhitespaceHandling::TRIM_WHITESPACE,
+                          base::SplitResult::SPLIT_WANT_NONEMPTY);
+    return base::ranges::find(split_encodings, "br") != split_encodings.end();
+  }
+
+  std::unique_ptr<net::test_server::HttpResponse>
+  HandleSubscriptionUpdateRequestWithUrlCheck(
+      std::string expected_url_part,
+      const net::test_server::HttpRequest& request) {
+    static const char kSubscriptionHeader[] =
+        "[Adblock Plus 2.0]\n"
+        "! Checksum: X5A8vtJDBW2a9EgS9glqbg\n"
+        "! Version: 202202061935\n"
+        "! Last modified: 06 Feb 2022 19:35 UTC\n"
+        "! Expires: 1 days (update frequency)\n\n";
+    if (base::StartsWith(request.relative_url, kSubscription,
+                         base::CompareCase::SENSITIVE) &&
+        !request_already_handled_) {
+      request_already_handled_ = true;
+      EXPECT_TRUE(RequestHeadersContainAcceptLanguage(request));
+      EXPECT_TRUE(RequestHeadersContainAcceptEncodingBrotli(request));
+      std::string os;
+      base::ReplaceChars(version_info::GetOSType(), base::kWhitespaceASCII, "",
+                         &os);
+      EXPECT_TRUE(request.relative_url.find(expected_url_part) !=
+                  std::string::npos);
+      EXPECT_TRUE(request.relative_url.find("addonName=eyeo-chromium-sdk") !=
+                  std::string::npos);
+      EXPECT_TRUE(request.relative_url.find("addonVersion=2.0.0") !=
+                  std::string::npos);
+      EXPECT_TRUE(request.relative_url.find("platformVersion=1.0") !=
+                  std::string::npos);
+      EXPECT_TRUE(request.relative_url.find("platform=" + os) !=
+                  std::string::npos);
+      auto http_response =
+          std::make_unique<net::test_server::BasicHttpResponse>();
+      http_response->set_code(net::HTTP_OK);
+      http_response->set_content(kSubscriptionHeader);
+      http_response->set_content_type("text/plain");
+      return std::move(http_response);
+    }
+
+    // Unhandled requests result in the Embedded test server sending a 404.
+    return nullptr;
+  }
+
+  void ExpectFilterListRequestMadeWithLastVersion(std::string last_version) {
+    https_server_->RegisterRequestHandler(
+        base::BindRepeating(&AdblockSubscriptionServiceBrowserTest::
+                                HandleSubscriptionUpdateRequestWithUrlCheck,
+                            base::Unretained(this), last_version));
+    ASSERT_TRUE(https_server_->Start(kPort));
+  }
+
+  // adblock::SubscriptionService::SubscriptionObserver
+  void OnSubscriptionInstalled(const GURL& url) override {
+    if (base::StartsWith(url.spec(),
+                         https_server_->GetURL(kSubscription).spec())) {
+      // In order to ensure next run requests an update, mark the subscription
+      // as almost expired.
+      SubscriptionPersistentMetadataFactory::GetForBrowserContext(
+          browser()->profile())
+          ->SetExpirationInterval(url, base::Milliseconds(1));
+      NotifyTestFinished();
+    }
+  }
+
+  void NotifyTestFinished() {
+    finish_condition_met_ = true;
+    // If the test is currently waiting for the finish condition to be met, we
+    // need to quit the run loop.
+    if (quit_closure_) {
+      quit_closure_.Run();
+    }
+  }
+
+  void RunUntilTestFinished() {
+    // If the finish condition is already met, we don't need to run the run
+    // loop.
+    if (finish_condition_met_) {
+      return;
+    }
+    // Wait until NotifyTestFinished() gets called.
+    base::RunLoop run_loop;
+    quit_closure_ = run_loop.QuitClosure();
+    std::move(run_loop).Run();
+  }
+
+  std::unique_ptr<net::EmbeddedTestServer> https_server_;
+  bool request_already_handled_ = false;
+  static const char kSubscription[];
+  // Port is hardcoded so the server url is the same across tests
+  static const int kPort = 65432;
+  bool finish_condition_met_ = false;
+  base::RepeatingClosure quit_closure_;
+};
+
+const char AdblockSubscriptionServiceBrowserTest::kSubscription[] =
+    "/subscription.txt";
+
+IN_PROC_BROWSER_TEST_F(AdblockSubscriptionServiceBrowserTest, PRE_LastVersion) {
+  ExpectFilterListRequestMadeWithLastVersion("&lastVersion=0&");
+  // Downloading a filter list and setting its expiry time to almost zero, so
+  // the next run will have to update it ASAP.
+
+  auto* subscription_service =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile());
+  subscription_service->AddObserver(this);
+  // Using a custom subscription URL here because before test sets
+  // up the server then SubscriptionService already started fetching default
+  // subscriptions.
+  subscription_service
+      ->GetFilteringConfiguration(kAdblockFilteringConfigurationName)
+      ->AddFilterList(https_server_->GetURL(kSubscription));
+  // Wait until subscription is downloaded and stored.
+  RunUntilTestFinished();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockSubscriptionServiceBrowserTest, LastVersion) {
+  ExpectFilterListRequestMadeWithLastVersion("&lastVersion=202202061935&");
+  auto* subscription_service =
+      SubscriptionServiceFactory::GetForBrowserContext(browser()->profile());
+  subscription_service->AddObserver(this);
+  // Wait for subscription update to trigger a network request.
+  RunUntilTestFinished();
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockSubscriptionServiceBrowserTest,
+                       FilterFileDeletedAfterConversion) {
+  base::ScopedAllowBlockingForTesting allow_blocking;
+  ConversionExecutors* conversion_executors =
+      SubscriptionServiceFactory::GetInstance();
+  DCHECK(conversion_executors);
+  base::ScopedTempDir temp_dir;
+  ASSERT_TRUE(temp_dir.CreateUniqueTempDir());
+  const auto filter_list_path = temp_dir.GetPath().AppendASCII("easylist.txt");
+  std::vector<base::StringPiece> filter_list_contents = {
+      "[\"Adblock Plus 2.0\"]\n", "invalid file"};
+  for (const auto& file_content : filter_list_contents) {
+    base::WriteFile(filter_list_path, file_content);
+    ASSERT_TRUE(base::PathExists(filter_list_path));
+    base::RunLoop run_loop;
+    conversion_executors->ConvertFilterListFile(
+        DefaultSubscriptionUrl(), filter_list_path,
+        base::BindLambdaForTesting(
+            [&run_loop](ConversionResult result) { run_loop.Quit(); }));
+    run_loop.Run();
+    ASSERT_FALSE(base::PathExists(filter_list_path));
+  }
+}
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_telemetry_service_browsertest.cc b/chrome/browser/adblock/test/adblock_telemetry_service_browsertest.cc
new file mode 100644
index 0000000000..df7d73e861
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_telemetry_service_browsertest.cc
@@ -0,0 +1,294 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "base/json/json_reader.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "components/adblock/content/browser/factories/adblock_telemetry_service_factory.h"
+#include "components/adblock/core/activeping_telemetry_topic_provider.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+
+namespace adblock {
+
+class AdblockTelemetryServiceBrowserTestBase : public InProcessBrowserTest {
+ public:
+  // We need to set server and request handler asap
+  void SetUpInProcessBrowserTestFixture() override {
+    InProcessBrowserTest::SetUpInProcessBrowserTestFixture();
+    host_resolver()->AddRule(
+        ActivepingTelemetryTopicProvider::DefaultBaseUrl().host(), "127.0.0.1");
+    http_server_.RegisterRequestHandler(base::BindRepeating(
+        &AdblockTelemetryServiceBrowserTestBase::RequestHandler,
+        base::Unretained(this)));
+    ASSERT_TRUE(http_server_.Start());
+    ActivepingTelemetryTopicProvider::SetHttpPortForTesting(
+        http_server_.port());
+    auto testing_interval = base::Seconds(2);
+    ActivepingTelemetryTopicProvider::SetIntervalsForTesting(testing_interval);
+    AdblockTelemetryServiceFactory::GetInstance()
+        ->SetCheckAndDelayIntervalsForTesting(testing_interval,
+                                              testing_interval);
+  }
+
+  base::Value* GetFirstPing(absl::optional<base::Value>& parsed) {
+    return GetPayload(parsed)->Find("first_ping");
+  }
+
+  base::Value* GetLastPing(absl::optional<base::Value>& parsed) {
+    return GetPayload(parsed)->Find("last_ping");
+  }
+
+  base::Value* GetLastPingTag(absl::optional<base::Value>& parsed) {
+    return GetPayload(parsed)->Find("last_ping_tag");
+  }
+
+  base::Value* GetPreviousLastPing(absl::optional<base::Value>& parsed) {
+    return GetPayload(parsed)->Find("previous_last_ping");
+  }
+
+  void CloseBrowserFromAnyThread() {
+    content::GetUIThreadTaskRunner({base::TaskPriority::USER_BLOCKING})
+        ->PostTask(FROM_HERE,
+                   base::BindOnce(&AdblockTelemetryServiceBrowserTestBase::
+                                      CloseBrowserAsynchronously,
+                                  base::Unretained(this), browser()));
+  }
+
+  std::unique_ptr<net::test_server::HttpResponse> CreateResponse(
+      const std::string& token) {
+    auto http_response =
+        std::make_unique<net::test_server::BasicHttpResponse>();
+    http_response->set_code(net::HTTP_OK);
+    http_response->set_content("{\"token\": \"" + token + "\"}");
+    http_response->set_content_type("text/plain");
+    return std::move(http_response);
+  }
+
+  void NotifyTestFinished() {
+    finish_condition_met_ = true;
+    // If the test is currently waiting for the finish condition to be met, we
+    // need to quit the run loop.
+    if (quit_closure_) {
+      quit_closure_.Run();
+    }
+  }
+
+  void RunUntilTestFinished() {
+    // If the finish condition is already met, we don't need to run the run
+    // loop.
+    if (finish_condition_met_) {
+      return;
+    }
+    // Wait until NotifyTestFinished() gets called.
+    base::RunLoop run_loop;
+    quit_closure_ = run_loop.QuitClosure();
+    std::move(run_loop).Run();
+  }
+
+  virtual std::unique_ptr<net::test_server::HttpResponse> RequestHandler(
+      const net::test_server::HttpRequest& request) = 0;
+
+ private:
+  base::Value::Dict* GetPayload(absl::optional<base::Value>& parsed) {
+    EXPECT_TRUE(parsed && parsed->is_dict());
+    base::Value::Dict* parsed_dict = parsed->GetIfDict();
+    EXPECT_TRUE(parsed_dict);
+    base::Value::Dict* payload = parsed_dict->FindDict("payload");
+    EXPECT_TRUE(payload);
+    return payload;
+  }
+
+  net::EmbeddedTestServer http_server_;
+  bool finish_condition_met_ = false;
+  base::RepeatingClosure quit_closure_;
+};
+
+// Test three initial pings each after startup and each fails for the 1st time
+class AdblockTelemetryServiceFirstPingAfterRestartWithRetryBrowserTest
+    : public AdblockTelemetryServiceBrowserTestBase {
+ public:
+  std::unique_ptr<net::test_server::HttpResponse> RequestHandler(
+      const net::test_server::HttpRequest& request) override {
+    EXPECT_TRUE(base::StartsWith(request.relative_url,
+                                 "/topic/eyeochromium_activeping/version/1"));
+    EXPECT_TRUE(request.has_content);
+    absl::optional<base::Value> parsed =
+        base::JSONReader::Read(request.content);
+    base::Value* first_ping = GetFirstPing(parsed);
+    base::Value* last_ping = GetLastPing(parsed);
+    base::Value* previous_last_ping = GetPreviousLastPing(parsed);
+
+    if (expected_first_ping_.empty()) {
+      EXPECT_FALSE(first_ping);
+    } else {
+      EXPECT_EQ(expected_first_ping_, *first_ping);
+    }
+
+    if (expected_last_ping_.empty()) {
+      EXPECT_FALSE(last_ping);
+    } else {
+      EXPECT_EQ(expected_last_ping_, *last_ping);
+    }
+
+    if (expected_previous_last_ping_.empty()) {
+      EXPECT_FALSE(previous_last_ping);
+    } else {
+      EXPECT_EQ(expected_previous_last_ping_, *previous_last_ping);
+    }
+
+    if (!attempt_++) {
+      // Force retry by 404 response but 1st save last_ping_tag if any
+      base::Value* last_ping_tag = GetLastPingTag(parsed);
+      if (last_ping_tag) {
+        previous_last_ping_tag_ = last_ping_tag->GetString();
+      }
+      return nullptr;
+    }
+
+    // Verifies that retried ping has the same last_ping_tag
+    if (!previous_last_ping_tag_.empty()) {
+      base::Value* last_ping_tag = GetLastPingTag(parsed);
+      EXPECT_EQ(previous_last_ping_tag_, *last_ping_tag);
+    }
+
+    NotifyTestFinished();
+
+    return CreateResponse(server_response_);
+  }
+
+  void SetUpInProcessBrowserTestFixture() override {
+    // Here we set returned ping values (server_response_) for current test and
+    // expectations (expected_*_) about ping values for the next test run.
+    // We need to set expectations for telemetry before actual test runs so
+    // we do it in SetUpInProcessBrowserTestFixture.
+    if (base::StartsWith(
+            ::testing::UnitTest::GetInstance()->current_test_info()->name(),
+            "PRE_PRE_TestPing")) {
+      server_response_ = "11111";
+    } else if (base::StartsWith(::testing::UnitTest::GetInstance()
+                                    ->current_test_info()
+                                    ->name(),
+                                "PRE_TestPing")) {
+      server_response_ = "22222";
+      expected_first_ping_ = expected_last_ping_ = "11111";
+    } else if (base::StartsWith(::testing::UnitTest::GetInstance()
+                                    ->current_test_info()
+                                    ->name(),
+                                "TestPing")) {
+      expected_first_ping_ = "11111";
+      expected_last_ping_ = "22222";
+      expected_previous_last_ping_ = "11111";
+    }
+    AdblockTelemetryServiceBrowserTestBase::SetUpInProcessBrowserTestFixture();
+  }
+
+  void TearDownInProcessBrowserTestFixture() override {
+    // Make sure we called RequestHandler exactly twice: 1st ping failed, 2nd
+    // was successful
+    EXPECT_EQ(2, attempt_);
+  }
+
+ protected:
+  std::string server_response_;
+  std::string expected_first_ping_;
+  std::string expected_last_ping_;
+  std::string expected_previous_last_ping_;
+
+ private:
+  int attempt_ = 0;
+  std::string previous_last_ping_tag_ = "";
+};
+
+IN_PROC_BROWSER_TEST_F(
+    AdblockTelemetryServiceFirstPingAfterRestartWithRetryBrowserTest,
+    PRE_PRE_TestPing) {
+  RunUntilTestFinished();
+}
+
+IN_PROC_BROWSER_TEST_F(
+    AdblockTelemetryServiceFirstPingAfterRestartWithRetryBrowserTest,
+    PRE_TestPing) {
+  RunUntilTestFinished();
+}
+
+IN_PROC_BROWSER_TEST_F(
+    AdblockTelemetryServiceFirstPingAfterRestartWithRetryBrowserTest,
+    TestPing) {
+  RunUntilTestFinished();
+}
+
+// Test three inital pings
+class AdblockTelemetryServiceSubsequentPingsBrowserTest
+    : public AdblockTelemetryServiceBrowserTestBase {
+ public:
+  std::unique_ptr<net::test_server::HttpResponse> RequestHandler(
+      const net::test_server::HttpRequest& request) override {
+    EXPECT_TRUE(base::StartsWith(request.relative_url,
+                                 "/topic/eyeochromium_activeping/version/1"));
+    EXPECT_TRUE(request.has_content);
+    absl::optional<base::Value> parsed =
+        base::JSONReader::Read(request.content);
+    base::Value* first_ping = GetFirstPing(parsed);
+    base::Value* last_ping = GetLastPing(parsed);
+    base::Value* previous_last_ping = GetPreviousLastPing(parsed);
+
+    if (count_ == 1) {
+      // No ping payload in the very 1st ping
+      EXPECT_FALSE(first_ping);
+      EXPECT_FALSE(last_ping);
+    } else if (count_ == 2) {
+      // For 2nd ping `first_ping` == `last_ping`
+      EXPECT_EQ(first_ping_, *first_ping);
+      EXPECT_EQ(first_ping_, *last_ping);
+    } else if (count_ == 3) {
+      // From 3rd ping onward `first_ping` != `last_ping` and we also get
+      // `previous_last_ping`
+      EXPECT_EQ(first_ping_, *first_ping);
+      EXPECT_EQ(second_ping_, *last_ping);
+      EXPECT_EQ(first_ping_, *previous_last_ping);
+    }
+
+    // If we get three expected telemetry pings we simply finish the test by
+    // closing the browser, otherwise test will fail with a timeout.
+    if (count_ == 3) {
+      NotifyTestFinished();
+      return nullptr;
+    }
+    return CreateResponse(count_++ == 1 ? first_ping_ : second_ping_);
+  }
+
+  void TearDownInProcessBrowserTestFixture() override {
+    // Make sure we called RequestHandler exactly three times
+    EXPECT_EQ(3, count_);
+  }
+
+ private:
+  const std::string first_ping_ = "11111";
+  const std::string second_ping_ = "22222";
+  int count_ = 1;
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockTelemetryServiceSubsequentPingsBrowserTest,
+                       TestPing) {
+  RunUntilTestFinished();
+}
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_trusted_events_browsertest.cc b/chrome/browser/adblock/test/adblock_trusted_events_browsertest.cc
new file mode 100644
index 0000000000..cccac15170
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_trusted_events_browsertest.cc
@@ -0,0 +1,138 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "content/public/common/isolated_world_ids.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+
+namespace adblock {
+
+class AdblockTrustedEventsTest
+    : public InProcessBrowserTest,
+      public testing::WithParamInterface<content::IsolatedWorldIDs> {
+ public:
+  void SetUpOnMainThread() override {
+    host_resolver()->AddRule(kTestDomain, "127.0.0.1");
+    embedded_test_server()->ServeFilesFromSourceDirectory(
+        "chrome/test/data/adblock");
+    ASSERT_TRUE(embedded_test_server()->Start());
+  }
+
+  GURL GetPageUrl() {
+    return embedded_test_server()->GetURL(kTestDomain, "/trusted_events.html");
+  }
+
+  void NavigateToPage() {
+    ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetPageUrl()));
+    static std::string script =
+        R"(
+        function triggerJsClick() {
+          document.getElementById("test_button").click();
+          return false;
+        }
+        function dispatchJsClickEvent() {
+          let clickEvent = new Event('click');
+          document.getElementById("test_button").dispatchEvent(clickEvent);
+          return false;
+        }
+        function dispatchJsMouseoverEvent() {
+          let mouseoverEvent = new Event('mouseover');
+          document.getElementById("test_button").dispatchEvent(mouseoverEvent);
+          return false;
+        }
+        function reset(value) {
+          document.getElementById("result").value = (value ? value : "");
+          return false;
+        }
+        document.getElementById("test_button").addEventListener("click", (event) => reset(String(event.isTrusted)));
+        document.getElementById("test_button").addEventListener("mouseover", (event) => reset(String(event.isTrusted)));
+        document.getElementById("reset").onclick = reset;
+        document.getElementById("triggerJsClick").onclick = triggerJsClick;
+        document.getElementById("dispatchJsClickEvent").onclick = dispatchJsClickEvent;
+      )";
+    content::WebContents* web_contents =
+        browser()->tab_strip_model()->GetActiveWebContents();
+    (void)(content::EvalJs(
+        web_contents, script,
+        content::EvalJsOptions::EXECUTE_SCRIPT_DEFAULT_OPTIONS, GetParam()));
+  }
+
+  bool GetIsTrustedValue() {
+    content::WebContents* web_contents =
+        browser()->tab_strip_model()->GetActiveWebContents();
+    auto value =
+        content::EvalJs(web_contents, "document.getElementById('result').value")
+            .ExtractString();
+    CHECK(value == "true" || value == "false");
+    return value == "true";
+  }
+
+  void TriggerEvent(const std::string& js_code) {
+    content::WebContents* web_contents =
+        browser()->tab_strip_model()->GetActiveWebContents();
+    EXPECT_EQ(false, content::EvalJs(
+                         web_contents, js_code,
+                         content::EvalJsOptions::EXECUTE_SCRIPT_DEFAULT_OPTIONS,
+                         GetParam()));
+  }
+
+  bool IsAdblockWorld() {
+    return GetParam() == content::IsolatedWorldIDs::ISOLATED_WORLD_ID_ADBLOCK;
+  }
+
+ private:
+  static constexpr char kTestDomain[] = "test.org";
+};
+
+IN_PROC_BROWSER_TEST_P(AdblockTrustedEventsTest,
+                       VerifyClickEventTrustedInAdblockIsolatedWorld) {
+  NavigateToPage();
+  TriggerEvent("triggerJsClick();");
+  // Should be trusted only in adblock isolated world
+  EXPECT_EQ(IsAdblockWorld(), GetIsTrustedValue());
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockTrustedEventsTest,
+                       VerifyDispatchClickEventTrustedInAdblockIsolatedWorld) {
+  NavigateToPage();
+  TriggerEvent("dispatchJsClickEvent();");
+  // Should be trusted only in adblock isolated world
+  EXPECT_EQ(IsAdblockWorld(), GetIsTrustedValue());
+}
+
+IN_PROC_BROWSER_TEST_P(
+    AdblockTrustedEventsTest,
+    VerifyDispatchMouseoverEventTrustedInAdblockIsolatedWorld) {
+  NavigateToPage();
+  TriggerEvent("dispatchJsMouseoverEvent();");
+  // Should be trusted only in adblock isolated world
+  EXPECT_EQ(IsAdblockWorld(), GetIsTrustedValue());
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    All,
+    AdblockTrustedEventsTest,
+    testing::Values(content::IsolatedWorldIDs::ISOLATED_WORLD_ID_GLOBAL,
+                    content::IsolatedWorldIDs::ISOLATED_WORLD_ID_ADBLOCK,
+                    content::IsolatedWorldIDs::ISOLATED_WORLD_ID_CONTENT_END));
+
+}  // namespace adblock
diff --git a/chrome/browser/adblock/test/adblock_web_bundle_browsertest.cc b/chrome/browser/adblock/test/adblock_web_bundle_browsertest.cc
new file mode 100644
index 0000000000..4e17303199
--- /dev/null
+++ b/chrome/browser/adblock/test/adblock_web_bundle_browsertest.cc
@@ -0,0 +1,427 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <cstdint>
+#include <vector>
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/functional/bind.h"
+#include "base/path_service.h"
+#include "base/strings/string_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/in_process_browser_test.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/resource_classification_runner.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "components/web_package/web_bundle_builder.h"
+#include "content/public/test/browser_test.h"
+#include "content/public/test/browser_test_utils.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "net/test/embedded_test_server/request_handler_util.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace adblock {
+
+class AdblockWebBundleBrowserTest
+    : public InProcessBrowserTest,
+      public ResourceClassificationRunner::Observer {
+ public:
+  void SetUpOnMainThread() override {
+    InProcessBrowserTest::SetUpOnMainThread();
+    host_resolver()->AddRule("*", "127.0.0.1");
+    embedded_test_server()->RegisterDefaultHandler(
+        base::BindRepeating(&AdblockWebBundleBrowserTest::HandleFileRequest,
+                            base::Unretained(this)));
+    ASSERT_TRUE(embedded_test_server()->Start());
+    PrepareTempDirWithContent();
+    ResourceClassificationRunnerFactory::GetForBrowserContext(
+        browser()->profile())
+        ->AddObserver(this);
+  }
+
+  void TearDownOnMainThread() override {
+    ResourceClassificationRunnerFactory::GetForBrowserContext(
+        browser()->profile())
+        ->RemoveObserver(this);
+    InProcessBrowserTest::TearDownOnMainThread();
+  }
+
+  void PrepareTempDirWithContent() {
+    ASSERT_TRUE(temp_dir_.CreateUniqueTempDir());
+    CreateIndexFile();
+    CreateByResourceWebBundle();
+    CreateByBundleFileWebBundle();
+    CreateByScopeFileWebBundle();
+  }
+
+  std::string GetFileContentFromTestDir(
+      base::FilePath::StringType relative_path) {
+    base::FilePath root;
+    CHECK(base::PathService::Get(base::DIR_SRC_TEST_DATA_ROOT, &root));
+    root = root.AppendASCII("chrome/test/data/adblock/wbn");
+    std::string content;
+    CHECK(base::ReadFileToString(root.Append(relative_path), &content));
+    return content;
+  }
+
+  // In order for an html file to use absolute URLs in 'src' attributes to
+  // resources hosted by the embedded_test_server(), we need to replace
+  // {{{baseUrl}}} with the server's URL. It changes for every run.
+  std::string GetHtmlContentWithReplacements(
+      base::FilePath::StringType relative_path) {
+    std::string content = GetFileContentFromTestDir(relative_path);
+    base::ReplaceSubstringsAfterOffset(
+        &content, 0, "{{{baseUrl}}}",
+        embedded_test_server()->GetURL("example.org", "/").spec());
+    return content;
+  }
+
+  void CreateByResourceWebBundle() {
+    web_package::WebBundleBuilder builder;
+    builder.AddExchange("by_resource/blue_subresource_loading.css",
+                        {{":status", "200"}, {"content-type", "text/css"}},
+                        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+                            "by_resource/blue_subresource_loading.css")));
+    builder.AddExchange("by_resource/blue_subresource_loading.png",
+                        {{":status", "200"}, {"content-type", "image/png"}},
+                        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+                            "by_resource/blue_subresource_loading.png")));
+    builder.AddExchange("by_resource/red_subresource_loading.css",
+                        {{":status", "200"}, {"content-type", "text/css"}},
+                        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+                            "by_resource/red_subresource_loading.css")));
+    builder.AddExchange("by_resource/red_subresource_loading.png",
+                        {{":status", "200"}, {"content-type", "image/png"}},
+                        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+                            "by_resource/red_subresource_loading.png")));
+    builder.AddExchange(
+        "by_resource/xhr_result_1_subresource_loading.json",
+        {{":status", "200"}, {"content-type", "application/json"}},
+        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+            "by_resource/xhr_result_1_subresource_loading.json")));
+    builder.AddExchange(
+        "by_resource/fetch_result_1_subresource_loading.json",
+        {{":status", "200"}, {"content-type", "application/json"}},
+        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+            "by_resource/fetch_result_1_subresource_loading.json")));
+    builder.AddPrimaryURL(embedded_test_server()->GetURL("example.org", "/"));
+    const auto binary_data = builder.CreateBundle();
+    ASSERT_TRUE(base::WriteFile(
+        temp_dir_.GetPath().AppendASCII("by_resource.wbn"), binary_data));
+  }
+
+  void CreateByBundleFileWebBundle() {
+    web_package::WebBundleBuilder builder;
+    builder.AddExchange("by_bundle_file/green_subresource_loading.css",
+                        {{":status", "200"}, {"content-type", "text/css"}},
+                        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+                            "by_bundle_file/green_subresource_loading.css")));
+    builder.AddExchange("by_bundle_file/green_subresource_loading.png",
+                        {{":status", "200"}, {"content-type", "image/png"}},
+                        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+                            "by_bundle_file/green_subresource_loading.png")));
+    builder.AddExchange("by_bundle_file/purple_subresource_loading.css",
+                        {{":status", "200"}, {"content-type", "text/css"}},
+                        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+                            "by_bundle_file/purple_subresource_loading.css")));
+    builder.AddExchange("by_bundle_file/purple_subresource_loading.png",
+                        {{":status", "200"}, {"content-type", "image/png"}},
+                        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+                            "by_bundle_file/purple_subresource_loading.png")));
+    builder.AddExchange(
+        "by_bundle_file/xhr_result_2_subresource_loading.json",
+        {{":status", "200"}, {"content-type", "application/json"}},
+        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+            "by_bundle_file/xhr_result_2_subresource_loading.json")));
+    builder.AddExchange(
+        "by_bundle_file/fetch_result_2_subresource_loading.json",
+        {{":status", "200"}, {"content-type", "application/json"}},
+        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+            "by_bundle_file/fetch_result_2_subresource_loading.json")));
+    builder.AddPrimaryURL(embedded_test_server()->GetURL("example.org", "/"));
+    const auto binary_data = builder.CreateBundle();
+    ASSERT_TRUE(base::WriteFile(
+        temp_dir_.GetPath().AppendASCII("by_bundle_file.wbn"), binary_data));
+  }
+
+  void CreateByScopeFileWebBundle() {
+    web_package::WebBundleBuilder builder;
+    builder.AddExchange("by_scope/orange_subresource_loading.css",
+                        {{":status", "200"}, {"content-type", "text/css"}},
+                        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+                            "by_scope/orange_subresource_loading.css")));
+    builder.AddExchange("by_scope/orange_subresource_loading.png",
+                        {{":status", "200"}, {"content-type", "image/png"}},
+                        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+                            "by_scope/orange_subresource_loading.png")));
+    builder.AddExchange("by_scope/pink_subresource_loading.css",
+                        {{":status", "200"}, {"content-type", "text/css"}},
+                        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+                            "by_scope/pink_subresource_loading.css")));
+    builder.AddExchange("by_scope/pink_subresource_loading.png",
+                        {{":status", "200"}, {"content-type", "image/png"}},
+                        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+                            "by_scope/pink_subresource_loading.png")));
+    builder.AddExchange(
+        "by_scope/xhr_result_3_subresource_loading.json",
+        {{":status", "200"}, {"content-type", "application/json"}},
+        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+            "by_scope/xhr_result_3_subresource_loading.json")));
+    builder.AddExchange(
+        "by_scope/fetch_result_3_subresource_loading.json",
+        {{":status", "200"}, {"content-type", "application/json"}},
+        GetFileContentFromTestDir(FILE_PATH_LITERAL(
+            "by_scope/fetch_result_3_subresource_loading.json")));
+    builder.AddPrimaryURL(embedded_test_server()->GetURL("example.org", "/"));
+    const auto binary_data = builder.CreateBundle();
+    ASSERT_TRUE(base::WriteFile(temp_dir_.GetPath().AppendASCII("by_scope.wbn"),
+                                binary_data));
+  }
+
+  void CreateIndexFile() {
+    const auto html = GetHtmlContentWithReplacements(
+        FILE_PATH_LITERAL("index.html.mustache"));
+    ASSERT_TRUE(
+        base::WriteFile(temp_dir_.GetPath().AppendASCII("index.html"), html));
+  }
+
+  std::unique_ptr<net::test_server::HttpResponse> HandleFileRequest(
+      const net::test_server::HttpRequest& request) {
+    auto response =
+        net::test_server::HandleFileRequest(temp_dir_.GetPath(), request);
+    if (response) {
+      auto* basic =
+          static_cast<net::test_server::BasicHttpResponse*>(response.get());
+      if (temp_dir_.GetPath()
+              .AppendASCII(request.GetURL().path().substr(1))
+              .MatchesExtension(FILE_PATH_LITERAL(".wbn"))) {
+        basic->set_content_type("application/webbundle");
+      }
+      basic->AddCustomHeader("X-Content-Type-Options", "nosniff");
+      basic->AddCustomHeader("Access-Control-Allow-Origin", "*");
+    }
+    return response;
+  }
+
+  GURL GetUrl() {
+    return embedded_test_server()->GetURL("example.org", "/index.html");
+  }
+
+  void SetFilters(std::vector<std::string> filters) {
+    auto* adblock_configuration =
+        SubscriptionServiceFactory::GetForBrowserContext(browser()->profile())
+            ->GetFilteringConfiguration(kAdblockFilteringConfigurationName);
+    adblock_configuration->RemoveCustomFilter(kAllowlistEverythingFilter);
+    for (auto& filter : filters) {
+      adblock_configuration->AddCustomFilter(filter);
+    }
+  }
+
+  bool EvaluateJs(std::string value) {
+    return content::EvalJs(browser()
+                               ->tab_strip_model()
+                               ->GetActiveWebContents()
+                               ->GetPrimaryMainFrame(),
+                           value)
+        .ExtractBool();
+  }
+
+  bool IsImageLoaded(std::string selector) {
+    return EvaluateJs(
+        "(function(){ node = document.querySelector('" + selector +
+        "'); return node.complete && node.naturalHeight !== 0; })()");
+  }
+
+  bool IsCssBlocked(std::string selector) {
+    // On the test page, a box with this |id| is grey if element-specific CSS
+    // was blocked. Grey is the default color for divs, and gets overridden
+    // to element-specific colors by blockable CSS files.
+    return EvaluateJs(
+        "(function(){ return "
+        "window.getComputedStyle(document.querySelector('" +
+        selector + "')).backgroundColor == 'rgb(128, 128, 128)'; })()");
+  }
+
+  // Waits until the textContent of the selected item stops being "Pending" and
+  // returns whatever it's final value is.
+  // This asynchronous wait is because scripts that change the textContent may
+  // execute with a delay.
+  std::string GetSelectorTextContent(std::string selector) {
+    return content::EvalJs(browser()
+                               ->tab_strip_model()
+                               ->GetActiveWebContents()
+                               ->GetPrimaryMainFrame(),
+                           R"(
+ (async function (selector) {
+    return new Promise(resolve => {
+        if (!document.querySelector(selector).textContent.includes('Pending')) {
+            return resolve(document.querySelector(selector).textContent);
+        }
+
+        const observer = new MutationObserver(mutations => {
+            if (!document.querySelector(selector).textContent.includes('Pending')) {
+                resolve(document.querySelector(selector).textContent);
+                observer.disconnect();
+            }
+        });
+
+        observer.observe(document.body, {
+            childList: true,
+            subtree: true
+        });
+    });
+})(' )" + selector + "');")
+        .ExtractString();
+  }
+
+  bool IsXhrOrFetchRequestBlocked(std::string selector) {
+    return GetSelectorTextContent(selector).find("Error") != std::string::npos;
+  }
+
+  bool IsXhrOrFetchRequestAllowed(std::string selector) {
+    return GetSelectorTextContent(selector).find("succeeded") !=
+           std::string::npos;
+  }
+
+  // ResourceClassificationRunner::Observer:
+  void OnRequestMatched(const GURL& url,
+                        FilterMatchResult match_result,
+                        const std::vector<GURL>& parent_frame_urls,
+                        ContentType content_type,
+                        content::RenderFrameHost* render_frame_host,
+                        const GURL& subscription,
+                        const std::string& configuration_name) override {
+    if (match_result == FilterMatchResult::kBlockRule) {
+      blocked_ads_notifications_.push_back(url);
+    }
+  }
+
+  void OnPageAllowed(const GURL& url,
+                     content::RenderFrameHost* render_frame_host,
+                     const GURL& subscription,
+                     const std::string& configuration_name) override {}
+
+  void OnPopupMatched(const GURL& url,
+                      FilterMatchResult match_result,
+                      const GURL& opener_url,
+                      content::RenderFrameHost* render_frame_host,
+                      const GURL& subscription,
+                      const std::string& configuration_name) override {}
+
+  base::ScopedTempDir temp_dir_;
+  std::vector<GURL> blocked_ads_notifications_;
+};
+
+IN_PROC_BROWSER_TEST_F(AdblockWebBundleBrowserTest, BlockImageByResource) {
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl()));
+  const auto* blocked_image_selector =
+      R"(img[src="by_resource/blue_subresource_loading.png"])";
+  const auto* other_image_selector =
+      R"(img[src="by_resource/red_subresource_loading.png"])";
+  EXPECT_TRUE(IsImageLoaded(blocked_image_selector));
+  EXPECT_TRUE(IsImageLoaded(other_image_selector));
+  SetFilters({"/blue_subresource_loading.png"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl()));
+  EXPECT_FALSE(IsImageLoaded(blocked_image_selector));
+  EXPECT_TRUE(IsImageLoaded(other_image_selector));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockWebBundleBrowserTest, BlockCssByResource) {
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl()));
+  EXPECT_FALSE(IsCssBlocked("div.blue"));
+  SetFilters({"blue_subresource_loading.css"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl()));
+  EXPECT_TRUE(IsCssBlocked("div.blue"));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockWebBundleBrowserTest, BlockXhrByResource) {
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl()));
+  const auto* blocked_selector = "code#xhr_result_by_resource";
+  EXPECT_TRUE(IsXhrOrFetchRequestAllowed(blocked_selector));
+  SetFilters({"/xhr_result_1_subresource_loading.json"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl()));
+  EXPECT_TRUE(IsXhrOrFetchRequestBlocked(blocked_selector));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockWebBundleBrowserTest, BlockFetchByResource) {
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl()));
+  const auto* blocked_selector = "code#fetch_result_by_resource";
+  EXPECT_TRUE(IsXhrOrFetchRequestAllowed(blocked_selector));
+  SetFilters({"/fetch_result_1_subresource_loading.json"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl()));
+  EXPECT_TRUE(IsXhrOrFetchRequestBlocked(blocked_selector));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockWebBundleBrowserTest, BlockByBundle) {
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl()));
+  const auto* blocked_image_selector =
+      R"(img[src="by_bundle_file/green_subresource_loading.png"])";
+  EXPECT_TRUE(IsImageLoaded(blocked_image_selector));
+  EXPECT_FALSE(IsCssBlocked("div.green"));
+  EXPECT_FALSE(IsCssBlocked("div.purple"));
+  EXPECT_TRUE(IsXhrOrFetchRequestAllowed("code#xhr_result_by_bundle_file"));
+  EXPECT_TRUE(IsXhrOrFetchRequestAllowed("code#fetch_result_by_bundle_file"));
+
+  SetFilters({"by_bundle_file.wbn$webbundle"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl()));
+  EXPECT_FALSE(IsImageLoaded(blocked_image_selector));
+  EXPECT_TRUE(IsCssBlocked("div.green"));
+  EXPECT_TRUE(IsCssBlocked("div.purple"));
+  EXPECT_THAT(blocked_ads_notifications_,
+              testing::Contains(embedded_test_server()->GetURL(
+                  "example.org", "/by_bundle_file.wbn")));
+  // FIXME the following two expectations fail because the state of the requests
+  // is "pending" rather than allowed or blocked: DPD-1887
+  // EXPECT_TRUE(IsXhrOrFetchRequestBlocked("code#xhr_result_by_bundle_file"));
+  // EXPECT_TRUE(IsXhrOrFetchRequestBlocked("code#fetch_result_by_bundle_file"));
+}
+
+IN_PROC_BROWSER_TEST_F(AdblockWebBundleBrowserTest, BlockByScope) {
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl()));
+  const auto* blocked_image_selector =
+      R"(img[src="by_scope/orange_subresource_loading.png"])";
+  EXPECT_TRUE(IsImageLoaded(blocked_image_selector));
+  EXPECT_FALSE(IsCssBlocked("div.orange"));
+  EXPECT_FALSE(IsCssBlocked("div.pink"));
+  EXPECT_TRUE(IsXhrOrFetchRequestAllowed("code#xhr_result_by_scope"));
+  EXPECT_TRUE(IsXhrOrFetchRequestAllowed("code#fetch_result_by_scope"));
+
+  SetFilters({"by_scope/"});
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), GetUrl()));
+  EXPECT_FALSE(IsImageLoaded(blocked_image_selector));
+  EXPECT_TRUE(IsCssBlocked("div.orange"));
+  EXPECT_TRUE(IsCssBlocked("div.pink"));
+  EXPECT_TRUE(IsXhrOrFetchRequestBlocked("code#xhr_result_by_scope"));
+  EXPECT_TRUE(IsXhrOrFetchRequestBlocked("code#fetch_result_by_scope"));
+}
+
+// TODO:
+// - Mixed origins
+// - Signed bundles. including case of navigation between signed and unsigned
+// content.
+// - If you block the whole bundle, all resources requests to components
+// declared in <script type="webbundle"> should be aborted. See sample test
+// here:
+// https://gitlab.com/eyeo/adblockplus/abc/webext-sdk/-/merge_requests/623/diffs#c24c6bdc211dc8e196dc5e2e32ddbefeb5fd4390_179_179
+
+}  // namespace adblock
diff --git a/chrome/browser/browser_resources.grd b/chrome/browser/browser_resources.grd
index 6fa87969dc..a0d7005973 100644
--- a/chrome/browser/browser_resources.grd
+++ b/chrome/browser/browser_resources.grd
@@ -1,4 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
+<!--
+This source code is a part of eyeo Chromium SDK.
+Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
+-->
 <grit latest_public_release="0" current_release="1" output_all_resource_defines="false">
   <outputs>
     <output filename="grit/browser_resources.h" type="rc_header">
@@ -252,6 +256,8 @@
         <!-- FedCM -->
         <part file="ui/views/webid/resources/webid_resources.grdp" />
       </if>
+
+      <include name="IDR_EYEO_ML_SERVICE_EXTENSION_MANIFEST" file="resources\adblock_ml\manifest.json" type="BINDATA" />
     </includes>
   </release>
 </grit>
diff --git a/chrome/browser/chrome_browser_main.cc b/chrome/browser/chrome_browser_main.cc
index d6c9d21a0d..ce69bfb8a7 100644
--- a/chrome/browser/chrome_browser_main.cc
+++ b/chrome/browser/chrome_browser_main.cc
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/chrome_browser_main.h"
 
@@ -123,6 +127,7 @@
 #include "chrome/grit/branded_strings.h"
 #include "chrome/grit/generated_resources.h"
 #include "chrome/installer/util/google_update_settings.h"
+#include "components/adblock/content/browser/adblock_web_ui_controller_factory.h"
 #include "components/color/color_mixers.h"
 #include "components/device_event_log/device_event_log.h"
 #include "components/embedder_support/origin_trials/component_updater_utils.h"
@@ -1625,6 +1630,8 @@ int ChromeBrowserMainParts::PreMainMessageLoopRunImpl() {
   // called inside PostProfileInit.
   content::WebUIControllerFactory::RegisterFactory(
       ChromeWebUIControllerFactory::GetInstance());
+  content::WebUIControllerFactory::RegisterFactory(
+      adblock::AdblockWebUIControllerFactory::GetInstance());
   RegisterChromeWebUIConfigs();
   RegisterChromeUntrustedWebUIConfigs();
 
diff --git a/chrome/browser/client_hints/client_hints_browsertest.cc b/chrome/browser/client_hints/client_hints_browsertest.cc
index 69d28bd93f..00a247867d 100644
--- a/chrome/browser/client_hints/client_hints_browsertest.cc
+++ b/chrome/browser/client_hints/client_hints_browsertest.cc
@@ -1,6 +1,10 @@
 // Copyright 2017 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "components/client_hints/common/client_hints.h"
 
@@ -660,7 +664,12 @@ class ClientHintsBrowserTest : public policy::PolicyTest {
     std::unique_ptr<base::FeatureList> feature_list(new base::FeatureList);
     // Force-enable the ClientHintsFormFactors feature, so that the header is
     // represented in the various header counts.
-    feature_list->InitFromCommandLine(kDefaultFeatures, "");
+    feature_list->InitFromCommandLine(
+        kDefaultFeatures,
+        // Disabling AdblockPlus because the async implementation of
+        // AdblockURLLoaderThrottle::WillStartRequest confuses
+        // ThirdPartyURLLoaderInterceptor.
+        "AdblockPlus");
     return feature_list;
   }
 
diff --git a/chrome/browser/extensions/BUILD.gn b/chrome/browser/extensions/BUILD.gn
index c5f8622276..52adff5324 100644
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2014 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//build/config/chromebox_for_meetings/buildflags.gni")
 import("//build/config/chromeos/ui_mode.gni")
@@ -747,6 +750,7 @@ static_library("extensions") {
     "window_controller_list_observer.h",
   ]
 
+
   # Chrome OS does not support Native Messaging policies.
   if (!is_chromeos) {
     sources += [
@@ -836,6 +840,7 @@ static_library("extensions") {
     "//chrome/browser/safe_browsing:metrics_collector",
     "//chrome/browser/ui/tabs:tab_enums",
     "//chrome/browser/web_applications",
+    "//components/adblock/content:browser",
     "//components/cbor:cbor",
     "//components/commerce/core:pref_names",
     "//components/device_reauth",
diff --git a/chrome/browser/extensions/component_extensions_allowlist/allowlist.cc b/chrome/browser/extensions/component_extensions_allowlist/allowlist.cc
index a24f8adff5..a1b0b0c281 100644
--- a/chrome/browser/extensions/component_extensions_allowlist/allowlist.cc
+++ b/chrome/browser/extensions/component_extensions_allowlist/allowlist.cc
@@ -1,6 +1,10 @@
 // Copyright 2015 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/extensions/component_extensions_allowlist/allowlist.h"
 
@@ -33,6 +37,7 @@ bool IsComponentExtensionAllowlisted(const std::string& extension_id) {
   const char* const kAllowed[] = {
     extension_misc::kInAppPaymentsSupportAppId,
     extension_misc::kPdfExtensionId,
+    extension_misc::kEyeoMlServiceExtensionId,
 #if BUILDFLAG(IS_CHROMEOS)
     extension_misc::kAssessmentAssistantExtensionId,
 #endif
@@ -94,6 +99,7 @@ bool IsComponentExtensionAllowlisted(int manifest_resource_id) {
 #endif
     case IDR_NETWORK_SPEECH_SYNTHESIS_MANIFEST:
     case IDR_WEBSTORE_MANIFEST:
+    case IDR_EYEO_ML_SERVICE_EXTENSION_MANIFEST:
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
     // Separate ChromeOS list, as it is quite large.
diff --git a/chrome/browser/extensions/component_loader.cc b/chrome/browser/extensions/component_loader.cc
index d401778c81..4e63e65325 100644
--- a/chrome/browser/extensions/component_loader.cc
+++ b/chrome/browser/extensions/component_loader.cc
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/extensions/component_loader.h"
 
@@ -36,6 +40,7 @@
 #include "chrome/grit/branded_strings.h"
 #include "chrome/grit/browser_resources.h"
 #include "chrome/grit/generated_resources.h"
+#include "components/adblock/core/features.h"
 #include "components/crx_file/id_util.h"
 #include "components/nacl/common/buildflags.h"
 #include "components/version_info/version_info.h"
@@ -556,6 +561,11 @@ void ComponentLoader::AddDefaultComponentExtensionsWithBackgroundPages(
     return;
   }
 
+  if (base::FeatureList::IsEnabled(adblock::kEyeoMlServiceFeature)) {
+    Add(IDR_EYEO_ML_SERVICE_EXTENSION_MANIFEST,
+        base::FilePath(FILE_PATH_LITERAL("adblock_ml")));
+  }
+
   if (!skip_session_components) {
 #if BUILDFLAG(IS_CHROMEOS)
     Add(IDR_ECHO_MANIFEST,
diff --git a/chrome/browser/flag-metadata.json b/chrome/browser/flag-metadata.json
index 5856c3f6f6..f1bd50b207 100644
--- a/chrome/browser/flag-metadata.json
+++ b/chrome/browser/flag-metadata.json
@@ -1,3 +1,6 @@
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
+
 // This file lists metadata for chrome://flags entries. This metadata is used to
 // automatically expire flags, as part of the review process, and to clean up
 // flags that have become obsolete or unused. For more details, see:
@@ -4339,6 +4342,11 @@
     "owners": [ "khalidpeer@chromium.org", "chrome-journeys@google.com" ],
     "expiry_milestone": 130
   },
+  {
+    "name": "eyeo-ml-service",
+    "owners": [ "p.kolomiets@eyeo.com" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "fast-pair-debug-metadata",
     "owners": [
diff --git a/chrome/browser/flag-never-expire-list.json b/chrome/browser/flag-never-expire-list.json
index 58e436eb79..862a3225f2 100644
--- a/chrome/browser/flag-never-expire-list.json
+++ b/chrome/browser/flag-never-expire-list.json
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 //
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
+//
 // This file contains a list of flags that are permitted to have the
 // never-expire flag set (i.e., expiration milestone set to -1). This is a
 // separate file from flag-metadata.json so that that file can have per-file
@@ -79,6 +82,7 @@
   "enable-zero-copy",
   "extensions-on-chrome-urls",
   "external-navigation-debug-logs",
+  "eyeo-ml-service",
   "force-color-profile",
   "force-effective-connection-type",
   "force-show-update-menu-badge",
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
index 3849e4dca4..b772524cdb 100644
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -1,6 +1,10 @@
 // Copyright 2017 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/flag_descriptions.h"
 
@@ -306,6 +310,10 @@ const char kEnableBenchmarkingChoiceDefaultFeatureStates[] =
 const char kEnableBenchmarkingChoiceMatchFieldTrialTestingConfig[] =
     "Match Field Trial Testing Config";
 
+extern const char kEyeoMlServiceName[] = "Eyeo ML Service";
+extern const char kEyeoMlServiceDescription[] =
+    "Enable inference service for machine learning ad filtering snippets";
+
 const char kPreloadingOnPerformancePageName[] =
     "Preloading Settings on Performance Page";
 const char kPreloadingOnPerformancePageDescription[] =
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index 59bc7b9fdd..d9b53d47ce 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1,6 +1,10 @@
 // Copyright 2017 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #ifndef CHROME_BROWSER_FLAG_DESCRIPTIONS_H_
 #define CHROME_BROWSER_FLAG_DESCRIPTIONS_H_
@@ -196,6 +200,9 @@ extern const char kEnableBenchmarkingChoiceDisabled[];
 extern const char kEnableBenchmarkingChoiceDefaultFeatureStates[];
 extern const char kEnableBenchmarkingChoiceMatchFieldTrialTestingConfig[];
 
+extern const char kEyeoMlServiceName[];
+extern const char kEyeoMlServiceDescription[];
+
 #if BUILDFLAG(USE_FONTATIONS_BACKEND)
 extern const char kFontationsFontBackendName[];
 extern const char kFontationsFontBackendDescription[];
diff --git a/chrome/browser/net/errorpage_browsertest.cc b/chrome/browser/net/errorpage_browsertest.cc
index 8dc398103d..4e5e16fcd1 100644
--- a/chrome/browser/net/errorpage_browsertest.cc
+++ b/chrome/browser/net/errorpage_browsertest.cc
@@ -2,6 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
+
 #include <algorithm>
 #include <memory>
 #include <utility>
@@ -38,6 +42,7 @@
 #include "chrome/common/pref_names.h"
 #include "chrome/test/base/in_process_browser_test.h"
 #include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/core/adblock_switches.h"
 #include "components/browsing_data/content/browsing_data_helper.h"
 #include "components/embedder_support/switches.h"
 #include "components/error_page/content/browser/net_error_auto_reloader.h"
@@ -636,6 +641,9 @@ class ErrorPageAutoReloadTest : public InProcessBrowserTest {
  public:
   void SetUpCommandLine(base::CommandLine* command_line) override {
     command_line->AppendSwitch(embedder_support::kEnableAutoReload);
+    // The URLLoaderInterceptor is not resilient to the browser making
+    // adblock-related requests, they confuse this test.
+    command_line->AppendSwitch(adblock::switches::kDisableAdblock);
   }
 
   void TearDownOnMainThread() override { url_loader_interceptor_.reset(); }
diff --git a/chrome/browser/page_load_metrics/observers/ad_metrics/ads_page_load_metrics_observer_browsertest.cc b/chrome/browser/page_load_metrics/observers/ad_metrics/ads_page_load_metrics_observer_browsertest.cc
index c4ccdb4d5c..4fab683ad3 100644
--- a/chrome/browser/page_load_metrics/observers/ad_metrics/ads_page_load_metrics_observer_browsertest.cc
+++ b/chrome/browser/page_load_metrics/observers/ad_metrics/ads_page_load_metrics_observer_browsertest.cc
@@ -1,6 +1,10 @@
 // Copyright 2017 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "components/page_load_metrics/browser/observers/ad_metrics/ads_page_load_metrics_observer.h"
 
@@ -22,6 +26,7 @@
 #include "chrome/browser/ui/browser.h"
 #include "chrome/test/base/in_process_browser_test.h"
 #include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/core/features.h"
 #include "components/heavy_ad_intervention/heavy_ad_features.h"
 #include "components/page_load_metrics/browser/ads_page_load_metrics_test_waiter.h"
 #include "components/page_load_metrics/browser/observers/ad_metrics/ad_intervention_browser_test_utils.h"
@@ -1511,7 +1516,7 @@ class AdsPageLoadMetricsObserverResourceBrowserTest
          {heavy_ad_intervention::features::kHeavyAdIntervention, {}},
          {heavy_ad_intervention::features::kHeavyAdPrivacyMitigations,
           {{"host-threshold", "3"}}}},
-        {});
+        {adblock::kAdblockPlusFeature});
     if (IsReduceTransferSizeUpdatedIPCEnabled()) {
       reduce_ipc_feature_list_.InitAndEnableFeature(
           network::features::kReduceTransferSizeUpdatedIPC);
diff --git a/chrome/browser/preferences/BUILD.gn b/chrome/browser/preferences/BUILD.gn
index 6c99524a53..5c9f1842a0 100644
--- a/chrome/browser/preferences/BUILD.gn
+++ b/chrome/browser/preferences/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2019 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//build/config/android/rules.gni")
 import("//third_party/jni_zero/jni_zero.gni")
@@ -39,6 +42,7 @@ java_cpp_strings("java_pref_names_srcjar") {
   sources = [
     "//chrome/browser/enterprise/reporting/prefs.cc",
     "//chrome/common/pref_names.h",
+    "//components/adblock/core/common/adblock_prefs.cc",
     "//components/autofill/core/common/autofill_prefs.h",
     "//components/commerce/core/pref_names.h",
     "//components/dom_distiller/core/pref_names.h",
diff --git a/chrome/browser/prefs/chrome_pref_service_factory.cc b/chrome/browser/prefs/chrome_pref_service_factory.cc
index 4d20025ae9..37dd8ebfd5 100644
--- a/chrome/browser/prefs/chrome_pref_service_factory.cc
+++ b/chrome/browser/prefs/chrome_pref_service_factory.cc
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/prefs/chrome_pref_service_factory.h"
 
@@ -39,6 +43,7 @@
 #include "chrome/grit/branded_strings.h"
 #include "chrome/grit/browser_resources.h"
 #include "chrome/grit/generated_resources.h"
+#include "components/adblock/core/common/adblock_prefs.h"
 #include "components/component_updater/pref_names.h"
 #include "components/policy/core/browser/configuration_policy_pref_store.h"
 #include "components/pref_registry/pref_registry_syncable.h"
@@ -176,6 +181,12 @@ const prefs::TrackedPreferenceMetadata kTrackedPrefs[] = {
     {33, prefs::kGoogleServicesLastSignedInUsername,
      EnforcementLevel::ENFORCE_ON_LOAD, PrefTrackingStrategy::ATOMIC,
      ValueType::PERSONAL},
+    {100, adblock::common::prefs::kSubscriptionSignatures,
+     EnforcementLevel::ENFORCE_ON_LOAD, PrefTrackingStrategy::SPLIT,
+     ValueType::IMPERSONAL},
+    {101, adblock::common::prefs::kLastUsedSchemaVersion,
+     EnforcementLevel::ENFORCE_ON_LOAD, PrefTrackingStrategy::ATOMIC,
+     ValueType::IMPERSONAL},
 
     // See note at top, new items added here also need to be added to
     // histograms.xml's TrackedPreference enum.
diff --git a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
index f87971b70f..88a5991fb9 100644
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
@@ -1,6 +1,10 @@
 // Copyright 2013 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h"
 
@@ -217,6 +221,14 @@
 #include "chrome/browser/webid/federated_identity_permission_context_factory.h"
 #include "chrome/common/buildflags.h"
 #include "chrome/common/chrome_features.h"
+#include "components/adblock/content/browser/factories/adblock_telemetry_service_factory.h"
+#include "components/adblock/content/browser/factories/content_security_policy_injector_factory.h"
+#include "components/adblock/content/browser/factories/element_hider_factory.h"
+#include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
+#include "components/adblock/content/browser/factories/session_stats_factory.h"
+#include "components/adblock/content/browser/factories/sitekey_storage_factory.h"
+#include "components/adblock/content/browser/factories/subscription_persistent_metadata_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
 #include "components/autofill/content/browser/autofill_log_router_factory.h"
 #include "components/breadcrumbs/core/breadcrumbs_status.h"
 #include "components/captive_portal/core/buildflags.h"
@@ -266,6 +278,7 @@
 #include "chrome/browser/signin/signin_manager_android_factory.h"
 #include "components/commerce/core/commerce_feature_list.h"
 #include "components/commerce/core/proto/merchant_signal_db_content.pb.h"
+
 #else
 #include "chrome/browser/accessibility/live_caption/live_caption_controller_factory.h"
 #include "chrome/browser/accessibility/live_translate_controller_factory.h"
@@ -818,6 +831,14 @@ void ChromeBrowserMainExtraPartsProfiles::
   // Makes manual testing possible.
   FakeSmartCardDeviceServiceFactory::GetInstance();
 #endif
+  adblock::AdblockTelemetryServiceFactory::GetInstance();
+  adblock::ContentSecurityPolicyInjectorFactory::GetInstance();
+  adblock::ElementHiderFactory::GetInstance();
+  adblock::ResourceClassificationRunnerFactory::GetInstance();
+  adblock::SessionStatsFactory::GetInstance();
+  adblock::SitekeyStorageFactory::GetInstance();
+  adblock::SubscriptionPersistentMetadataFactory::GetInstance();
+  adblock::SubscriptionServiceFactory::GetInstance();
 #if BUILDFLAG(IS_ANDROID)
   FastCheckoutCapabilitiesFetcherFactory::GetInstance();
 #endif
diff --git a/chrome/browser/profiles/profile_keyed_service_browsertest.cc b/chrome/browser/profiles/profile_keyed_service_browsertest.cc
index 7e56ce9166..a470aca1b4 100644
--- a/chrome/browser/profiles/profile_keyed_service_browsertest.cc
+++ b/chrome/browser/profiles/profile_keyed_service_browsertest.cc
@@ -2,6 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
+
 #include <sstream>
 
 #include "base/containers/to_vector.h"
@@ -318,7 +322,7 @@ IN_PROC_BROWSER_TEST_F(ProfileKeyedServiceBrowserTest,
 #endif  // BUILDFLAG(IS_WIN)
     "UsbDeviceManager",
     "UsbDeviceResourceManager",
-    "sct_reporting::Factory"
+    "sct_reporting::Factory",
   };
   // clang-format on
 
@@ -588,6 +592,13 @@ IN_PROC_BROWSER_TEST_F(ProfileKeyedServiceBrowserTest,
     "feedback::FeedbackUploaderChrome",
     "sct_reporting::Factory",
     "ZeroSuggestCacheServiceFactory",
+
+    // eyeo Chromium SDK services:
+    "AdblockPrivateAPI",
+    "EyeoFilteringPrivateAPI",
+    "ResourceClassificationRunner",
+    "SessionStats",
+    "SitekeyStorage",
   };
   // clang-format on
 
@@ -634,6 +645,17 @@ IN_PROC_BROWSER_TEST_F(ProfileKeyedServiceBrowserTest,
     "PluginInfoHostImpl",
     "TurnSyncOnHelperShutdownNotifier",
     "WebUIContentsPreloadManager",
+
+    // Eyeo services
+    "AdblockSubscriptionPersistentMetadata",
+    "AdblockSubscriptionService",
+    "AdblockTelemetryService",
+    "ContentSecurityPolicyInjector",
+    "ElementHider",
+    "ResourceClassificationRunner",
+    "SessionStats",
+    "SitekeyStorage",
+
   };
   // clang-format on
 
diff --git a/chrome/browser/resources/BUILD.gn b/chrome/browser/resources/BUILD.gn
index 380c3c8419..ba49c9a057 100644
--- a/chrome/browser/resources/BUILD.gn
+++ b/chrome/browser/resources/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2014 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//build/config/chromeos/ui_mode.gni")
 import("//chrome/browser/buildflags.gni")
@@ -258,6 +261,7 @@ group("dev_ui_resources") {
     "privacy_sandbox/internals:resources",
     "usb_internals:resources",
     "//chrome/browser:dev_ui_browser_resources",
+    "//components/adblock/content/resources/adblock_internals:resources",
     "//components/commerce/core/internals/resources",
     "//components/download/resources/download_internals:resources",
     "//components/history_clusters/history_clusters_internals/resources",
@@ -316,6 +320,7 @@ repack("dev_ui_paks") {
     "$root_gen_dir/chrome/predictors_resources.pak",
     "$root_gen_dir/chrome/privacy_sandbox_internals_resources.pak",
     "$root_gen_dir/chrome/usb_internals_resources.pak",
+    "$root_gen_dir/components/adblock_internals_resources.pak",
     "$root_gen_dir/components/commerce_internals_resources.pak",
     "$root_gen_dir/components/dev_ui_components_resources.pak",
     "$root_gen_dir/components/download_internals_resources.pak",
diff --git a/chrome/browser/resources/adblock_ml/.gitignore b/chrome/browser/resources/adblock_ml/.gitignore
new file mode 100644
index 0000000000..870c6db32b
--- /dev/null
+++ b/chrome/browser/resources/adblock_ml/.gitignore
@@ -0,0 +1 @@
+mlaf
diff --git a/chrome/browser/resources/adblock_ml/manifest.json b/chrome/browser/resources/adblock_ml/manifest.json
new file mode 100644
index 0000000000..1d3f0e9e9b
--- /dev/null
+++ b/chrome/browser/resources/adblock_ml/manifest.json
@@ -0,0 +1,38 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+{
+  // Extension ID: phhdcbipnceblbigdhhoahagpfdblied
+  "key": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApqpEi2tVYEPrGTGjj68nOc059/awRN7NMMGIGYZbxVAr3xS2oujmawr5aVnQrA0NTsh79Gi/dxJWJ8mQ6qV6eXo9qXUHSz+WRTCpC3nvLc3o0ZLy/Yil4J+iZuflj7A7XE1ZOSJxZiTLjJFZwCDiOFMDe+zE+BXiOiqoVzPKZ+SIJqGSANgMs+RklDrXQb1719MTXOWIz1PXgMQTwIyBYa9HW1igf4kp9Tgq6PLGaihh2eEiTih52qLDueMmv6A6CYICIZ4Fdc9rH3yu2wv2D1MXWXNiENegQaml7z2StodtWaONDpiSmnTHCs+khNdZGLVYuDea+jpyapsytTNq3wIDAQAB",
+  "name": "Adblock ML",
+  // update version every time you change the code or wipe .config/chromium/Default/Service Worker
+  "version": "0.4.0",
+  "manifest_version": 3,
+  "background": {
+    "service_worker": "service.js",
+    "type": "module"
+  },
+  "externally_connectable": {
+    "matches": [
+      "<all_urls>"
+    ]
+  },
+  "incognito": "spanning",
+  "host_permissions": [
+    // model download
+    "https://easylist-downloads.adblockplus.org/models/*",
+    // telemetry
+    "https://*.gcp.data.eyeo.it/*"
+  ]
+}
diff --git a/chrome/browser/resources/adblock_ml/service.js b/chrome/browser/resources/adblock_ml/service.js
new file mode 100644
index 0000000000..51bafeeb3e
--- /dev/null
+++ b/chrome/browser/resources/adblock_ml/service.js
@@ -0,0 +1,20 @@
+/*
+ * This file is part of eyeo Chromium SDK,
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * eyeo Chromium SDK is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * eyeo Chromium SDK is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+import {messageListener} from './mlaf/lib/webextension/service.min.js';
+
+chrome.runtime.onMessageExternal.addListener(messageListener);
diff --git a/chrome/browser/resources/component_extension_resources.grd b/chrome/browser/resources/component_extension_resources.grd
index c0b9725484..aa11cc0ffb 100644
--- a/chrome/browser/resources/component_extension_resources.grd
+++ b/chrome/browser/resources/component_extension_resources.grd
@@ -1,4 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
+<!--
+This source code is a part of eyeo Chromium SDK.
+Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
+-->
 <!-- This comment is only here because changes to resources are not picked up
      without changes to the corresponding grd file.  -->
 <grit latest_public_release="0" current_release="1" output_all_resource_defines="false">
@@ -74,6 +78,9 @@
       <include name="IDS_READING_MODE_DARK_PNG" file="side_panel/read_anything/images/read_anything_dark.png" type="BINDATA" />
       <include name="IDS_READING_MODE_YELLOW_PNG" file="side_panel/read_anything/images/read_anything_yellow.png" type="BINDATA" />
       <include name="IDS_READING_MODE_BLUE_PNG" file="side_panel/read_anything/images/read_anything_blue.png" type="BINDATA" />
+
+      <include name="IDR_EYEO_ML_SERVICE_HEAD_JS" file="adblock_ml/service.js" type="BINDATA" />
+      <include name="IDR_EYEO_ML_SERVICE_BODY_JS" file="adblock_ml/mlaf/lib/webextension/service.min.js" type="BINDATA" compress="gzip" />
     </includes>
 
     <!-- Game Controls lottie json files -->
diff --git a/chrome/browser/safe_browsing/safe_browsing_blocking_page_test.cc b/chrome/browser/safe_browsing/safe_browsing_blocking_page_test.cc
index f6bb897819..c8e2592a27 100644
--- a/chrome/browser/safe_browsing/safe_browsing_blocking_page_test.cc
+++ b/chrome/browser/safe_browsing/safe_browsing_blocking_page_test.cc
@@ -5,6 +5,10 @@
 // This test creates a fake safebrowsing service, where we can inject known-
 // threat urls.  It then uses a real browser to go to these urls, and sends
 // "goback" or "proceed" commands and verifies they work.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include <algorithm>
 #include <map>
@@ -66,6 +70,7 @@
 #include "chrome/common/url_constants.h"
 #include "chrome/test/base/in_process_browser_test.h"
 #include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/core/features.h"
 #include "components/google/core/common/google_util.h"
 #include "components/grit/components_resources.h"
 #include "components/omnibox/browser/omnibox_prefs.h"
@@ -664,7 +669,7 @@ class SafeBrowsingBlockingPageBrowserTest
     scoped_feature_list_.InitWithFeaturesAndParameters(
         {tag_and_attribute, add_warning_shown_timestamp_csbrrs,
          create_warning_shown_csbrrs},
-        {});
+        {adblock::kAdblockPlusFeature});
   }
 
   SafeBrowsingBlockingPageBrowserTest(
diff --git a/chrome/browser/subresource_filter/subresource_filter_browser_test_harness.cc b/chrome/browser/subresource_filter/subresource_filter_browser_test_harness.cc
index 10e4db8c92..7c77f63ec5 100644
--- a/chrome/browser/subresource_filter/subresource_filter_browser_test_harness.cc
+++ b/chrome/browser/subresource_filter/subresource_filter_browser_test_harness.cc
@@ -1,6 +1,10 @@
 // Copyright 2017 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/subresource_filter/subresource_filter_browser_test_harness.h"
 
@@ -22,6 +26,7 @@
 #include "chrome/common/chrome_features.h"
 #include "chrome/common/chrome_paths.h"
 #include "chrome/test/base/chrome_test_utils.h"
+#include "components/adblock/core/features.h"
 #include "components/blocked_content/safe_browsing_triggered_popup_blocker.h"
 #include "components/content_settings/browser/page_specific_content_settings.h"
 #include "components/safe_browsing/core/browser/db/v4_protocol_manager_util.h"
@@ -70,7 +75,8 @@ MockSubresourceFilterObserver::~MockSubresourceFilterObserver() = default;
 SubresourceFilterBrowserTest::SubresourceFilterBrowserTest() {
   scoped_feature_list_.InitWithFeatures(
       /*enabled_features=*/{kAdTagging},
-      /*disabled_features=*/{features::kHttpsUpgrades});
+      /*disabled_features=*/{features::kHttpsUpgrades,
+                             adblock::kAdblockPlusFeature});
 }
 
 SubresourceFilterBrowserTest::~SubresourceFilterBrowserTest() = default;
diff --git a/chrome/browser/ui/BUILD.gn b/chrome/browser/ui/BUILD.gn
index f61a369f16..02f10d4749 100644
--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2014 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//build/config/buildflags_paint_preview.gni")
 import("//build/config/chromeos/ui_mode.gni")
@@ -484,6 +487,7 @@ static_library("ui") {
     "//components/about_ui",
     "//components/access_code_cast/common:metrics",
     "//components/account_id",
+    "//components/adblock/content:browser",
     "//components/affiliations/core/browser:affiliations",
     "//components/autofill/content/browser",
     "//components/autofill/content/browser:risk_proto",
@@ -1077,6 +1081,7 @@ static_library("ui") {
 
     # TODO(b/335257259): Resolve circular deps.
     allow_circular_includes_from += [ "//chrome/browser/facilitated_payments" ]
+
   } else {
     # !is_android
     sources += [
diff --git a/chrome/browser/ui/prefs/pref_watcher.cc b/chrome/browser/ui/prefs/pref_watcher.cc
index 3a3a92656c..9718ba4e8d 100644
--- a/chrome/browser/ui/prefs/pref_watcher.cc
+++ b/chrome/browser/ui/prefs/pref_watcher.cc
@@ -2,6 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
+
 #include "chrome/browser/ui/prefs/pref_watcher.h"
 
 #include "base/functional/bind.h"
@@ -13,6 +17,7 @@
 #include "chrome/browser/renderer_preferences_util.h"
 #include "chrome/browser/ui/prefs/prefs_tab_helper.h"
 #include "chrome/common/pref_names.h"
+#include "components/adblock/core/common/adblock_prefs.h"
 #include "components/language/core/browser/pref_names.h"
 #include "components/live_caption/pref_names.h"
 #include "components/privacy_sandbox/tracking_protection_settings.h"
@@ -69,6 +74,14 @@ const char* const kWebPrefsToObserve[] = {
 #else
     prefs::kAccessibilityFocusHighlightEnabled,
 #endif
+
+    adblock::common::prefs::kAdblockAllowedDomainsLegacy,
+    adblock::common::prefs::kAdblockCustomFiltersLegacy,
+    adblock::common::prefs::kAdblockCustomSubscriptionsLegacy,
+    adblock::common::prefs::kAdblockSubscriptionsLegacy,
+    adblock::common::prefs::kEnableAcceptableAdsLegacy,
+    adblock::common::prefs::kEnableAdblockLegacy,
+
 };
 
 const int kWebPrefsToObserveLength = std::size(kWebPrefsToObserve);
diff --git a/chrome/browser/ui/tab_helpers.cc b/chrome/browser/ui/tab_helpers.cc
index 796441c106..b2dd86007f 100644
--- a/chrome/browser/ui/tab_helpers.cc
+++ b/chrome/browser/ui/tab_helpers.cc
@@ -1,6 +1,10 @@
 // Copyright 2014 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/ui/tab_helpers.h"
 
@@ -114,6 +118,11 @@
 #include "chrome/common/chrome_features.h"
 #include "chrome/common/chrome_isolated_world_ids.h"
 #include "chrome/common/chrome_switches.h"
+#include "components/adblock/content/browser/adblock_webcontents_observer.h"
+#include "components/adblock/content/browser/factories/adblock_telemetry_service_factory.h"
+#include "components/adblock/content/browser/factories/element_hider_factory.h"
+#include "components/adblock/content/browser/factories/sitekey_storage_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
 #include "components/autofill/content/browser/content_autofill_client.h"
 #include "components/autofill/content/browser/content_autofill_driver_factory.h"
 #include "components/autofill/core/browser/browser_autofill_manager.h"
@@ -370,9 +379,22 @@ void TabHelpers::AttachTabHelpers(WebContents* web_contents) {
                                                    optimization_guide_decider);
     }
   }
+
+  auto* original_profile = profile->GetOriginalProfile();
+  adblock::AdblockTelemetryServiceFactory::GetForBrowserContext(
+      original_profile);
+  AdblockWebContentObserver::CreateForWebContents(
+      web_contents,
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          original_profile),
+      adblock::ElementHiderFactory::GetForBrowserContext(original_profile),
+      adblock::SitekeyStorageFactory::GetForBrowserContext(original_profile),
+      std::make_unique<adblock::FrameHierarchyBuilder>());
+
   autofill::AutofillClientProvider& autofill_client_provider =
       autofill::AutofillClientProviderFactory::GetForProfile(profile);
   autofill_client_provider.CreateClientForWebContents(web_contents);
+
   if (breadcrumbs::IsEnabled(g_browser_process->local_state())) {
     BreadcrumbManagerTabHelper::CreateForWebContents(web_contents);
   }
diff --git a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
index 3de04cfb90..8989d722e3 100644
--- a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
+++ b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
@@ -406,6 +406,7 @@ WebUIFactoryFunction GetWebUIFactoryFunction(WebUI* web_ui,
   //
   // We must compare hosts only since some of the Web UIs append extra stuff
   // after the host name.
+
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   if (url.host_piece() == chrome::kChromeUIAppDisabledHost)
     return &NewWebUI<chromeos::ChromeURLDisabledUI>;
diff --git a/chrome/chrome_paks.gni b/chrome/chrome_paks.gni
index 55de354155..440cbd250f 100644
--- a/chrome/chrome_paks.gni
+++ b/chrome/chrome_paks.gni
@@ -1,6 +1,9 @@
 # Copyright 2016 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//ash/ambient/resources/resources.gni")
 import("//build/config/chromeos/ui_mode.gni")
@@ -108,6 +111,7 @@ template("chrome_extra_paks") {
       "$root_gen_dir/chrome/common_resources.pak",
       "$root_gen_dir/chrome/data_sharing_internals_resources.pak",
       "$root_gen_dir/chrome/segmentation_internals_resources.pak",
+      "$root_gen_dir/components/adblock/core/resources/adblock_resources.pak",
       "$root_gen_dir/components/autofill/core/browser/autofill_address_rewriter_resources.pak",
       "$root_gen_dir/components/components_resources.pak",
       "$root_gen_dir/components/flags_ui_resources.pak",
@@ -130,6 +134,7 @@ template("chrome_extra_paks") {
       "//chrome/browser:resources",
       "//chrome/browser/resources:resources",
       "//chrome/common:resources",
+      "//components/adblock/core/resources:adblock_resources",
       "//components/autofill/core/browser:autofill_address_rewriter_resources",
       "//components/resources",
       "//content:content_resources",
diff --git a/chrome/common/BUILD.gn b/chrome/common/BUILD.gn
index 2d7c5d7155..44d130eb71 100644
--- a/chrome/common/BUILD.gn
+++ b/chrome/common/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2014 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//build/buildflag_header.gni")
 import("//build/config/chrome_build.gni")
diff --git a/chrome/common/extensions/extension_constants.cc b/chrome/common/extensions/extension_constants.cc
index 8843a31098..4c772a52d1 100644
--- a/chrome/common/extensions/extension_constants.cc
+++ b/chrome/common/extensions/extension_constants.cc
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/common/extensions/extension_constants.h"
 
@@ -32,6 +36,7 @@ const char kGooglePlusAppId[] = "dlppkpafhbajpcmmoheippocdidnckmm";
 const char kTextEditorAppId[] = "mmfbcljfglbokpmkimbfghdkjmjhdgbg";
 const char kInAppPaymentsSupportAppId[] = "nmmhkkegccagdldgiimedpiccmgmieda";
 const char kKeyboardExtensionId[] = "mppnpdlheglhdfmldimlhpnegondlapf";
+const char kEyeoMlServiceExtensionId[] = "phhdcbipnceblbigdhhoahagpfdblied";
 
 const char* const kBuiltInFirstPartyExtensionIds[] = {
     kCalculatorAppId,
diff --git a/chrome/common/extensions/extension_constants.h b/chrome/common/extensions/extension_constants.h
index b14be4de1a..f4b7339f1d 100644
--- a/chrome/common/extensions/extension_constants.h
+++ b/chrome/common/extensions/extension_constants.h
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #ifndef CHROME_COMMON_EXTENSIONS_EXTENSION_CONSTANTS_H_
 #define CHROME_COMMON_EXTENSIONS_EXTENSION_CONSTANTS_H_
@@ -63,6 +67,9 @@ extern const char kInAppPaymentsSupportAppId[];
 // The extension id of virtual keyboard extension.
 extern const char kKeyboardExtensionId[];
 
+// The extension id of adblock ml extension.
+extern const char kEyeoMlServiceExtensionId[];
+
 // A list of all the first party extension IDs, last entry is null.
 extern const char* const kBuiltInFirstPartyExtensionIds[];
 
diff --git a/chrome/test/BUILD.gn b/chrome/test/BUILD.gn
index 25ffa1ddfb..b312134021 100644
--- a/chrome/test/BUILD.gn
+++ b/chrome/test/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2014 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//build/cipd/cipd.gni")
 import("//build/config/buildflags_paint_preview.gni")
@@ -22,6 +25,7 @@ import("//chrome/services/speech/buildflags/buildflags.gni")
 import("//chrome/test/include_js_tests.gni")
 import("//chrome/version.gni")
 import("//chromeos/ash/components/assistant/assistant.gni")
+import("//components/adblock/features.gni")
 import("//components/allocation_recorder/testing/testing.gni")
 import("//components/captive_portal/core/features.gni")
 import("//components/compose/features.gni")
@@ -1417,6 +1421,7 @@ if (is_android) {
     deps += [
       ":persisted_tab_data_test_proto",
       "//chrome/browser/password_manager/android:test_support",
+      "//components/adblock/content:browser",
       "//components/autofill/content/browser:test_support",
       "//components/back_forward_cache:back_forward_cache",
       "//components/browsing_data/core:core",
@@ -1796,6 +1801,7 @@ if (!is_android) {
       "//chrome/test/data/webui/mojo:mojo_bindings",
       "//chrome/test/media_router/access_code_cast:access_code_cast_integration_base",
       "//chrome/test/payments:test_support",
+      "//components/adblock/content:browser",
       "//components/affiliations/core/browser:affiliation_proto",
       "//components/affiliations/core/browser:test_support",
       "//components/autofill/content/browser:autofill_shared_storage_proto",
@@ -2181,6 +2187,7 @@ if (!is_android) {
       "//ash/components/arc/test/data/icons",
       "//chrome/browser/page_load_metrics/integration_tests/data/",
       "//chrome/renderer/resources/extensions/",
+      "//chrome/test/data/adblock/",
       "//chrome/test/data/cart/",
       "//components/test/data/ad_tagging/",
       "//components/test/data/ads_observer/",
@@ -2270,6 +2277,22 @@ if (!is_android) {
       "../browser/accessibility/image_annotation_browsertest.cc",
       "../browser/accessibility/interstitial_accessibility_browsertest.cc",
       "../browser/accessibility/page_colors_browsertest.cc",
+      "../browser/adblock/test/adblock_acceptable_ads_browsertest.cc",
+      "../browser/adblock/test/adblock_chrome_content_browser_client_browsertest.cc",
+      "../browser/adblock/test/adblock_content_filters_browsertest.cc",
+      "../browser/adblock/test/adblock_filter_list_browsertest.cc",
+      "../browser/adblock/test/adblock_filtering_configurations_browsertest.cc",
+      "../browser/adblock/test/adblock_frame_hierarchy_builder_browsertest.cc",
+      "../browser/adblock/test/adblock_ml_browsertest.cc",
+      "../browser/adblock/test/adblock_multiple_tabs_browsertest.cc",
+      "../browser/adblock/test/adblock_non_ascii_browsertest.cc",
+      "../browser/adblock/test/adblock_popup_browsertest.cc",
+      "../browser/adblock/test/adblock_service_workers_browsertest.cc",
+      "../browser/adblock/test/adblock_snippets_browsertest.cc",
+      "../browser/adblock/test/adblock_subscription_service_browsertest.cc",
+      "../browser/adblock/test/adblock_telemetry_service_browsertest.cc",
+      "../browser/adblock/test/adblock_trusted_events_browsertest.cc",
+      "../browser/adblock/test/adblock_web_bundle_browsertest.cc",
       "../browser/apps/guest_view/app_view_browsertest.cc",
       "../browser/apps/guest_view/web_view_browsertest.cc",
       "../browser/apps/platform_apps/app_browsertest.cc",
@@ -3037,6 +3060,10 @@ if (!is_android) {
       sources += [ "../browser/chrome_for_testing/chrome_for_testing_info_bar_browsertest.cc" ]
     }
 
+    if (eyeo_intercept_debug_url) {
+      sources += [ "../browser/adblock/test/adblock_debug_url_browsertest.cc" ]
+    }
+
     if (enable_reporting) {
       sources += [ "../browser/net/reporting_browsertest.cc" ]
     }
@@ -3939,6 +3966,7 @@ if (!is_android) {
         ]
       }
 
+
       if (is_chromeos_ash && enable_extensions) {
         deps +=
             [ "//chromeos/ash/components/network/portal_detector:test_support" ]
@@ -6206,6 +6234,7 @@ test("unit_tests") {
   sources = [
     # All unittests in browser, common, renderer and service.
     "../browser/about_flags_unittest.cc",
+    "../browser/adblock/adblock_chrome_content_browser_client_unittest.cc",
     "../browser/after_startup_task_utils_unittest.cc",
     "../browser/apps/icon_standardizer_unittest.cc",
     "../browser/apps/user_type_filter_unittest.cc",
@@ -6894,6 +6923,8 @@ test("unit_tests") {
     "//chrome/services/file_util:unit_tests",
     "//chrome/services/on_device_translation:unit_tests",
     "//components/account_id",
+    "//components/adblock/content/browser:test_support",
+    "//components/adblock/core:test_support",
     "//components/affiliations/core/browser:test_support",
     "//components/assist_ranker/proto",
     "//components/autofill/content/browser:test_support",
@@ -7217,7 +7248,6 @@ test("unit_tests") {
     "//ui/web_dialogs:web_dialogs_unittests",
     "//ui/webui",
     "//v8",
-
     # Duplicate these tests here because PathService has more providers in
     # unit_tests than in base_unittests.
     "//base:path_service_unittest",
@@ -10670,6 +10700,7 @@ if (!is_android) {
 
     public_deps = [
       "//chrome/browser:test_support_ui",
+      "//components/adblock/core:test_support",
       "//components/supervised_user/core/browser",
       "//content/public/browser",
       "//content/test:test_support",
diff --git a/chrome/test/base/chrome_test_launcher.cc b/chrome/test/base/chrome_test_launcher.cc
index cbd6ac277a..986b18ed06 100644
--- a/chrome/test/base/chrome_test_launcher.cc
+++ b/chrome/test/base/chrome_test_launcher.cc
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/test/base/chrome_test_launcher.h"
 
@@ -26,6 +30,7 @@
 #include "base/time/time.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
+#include "chrome/browser/adblock/adblock_chrome_content_browser_client.h"
 #include "chrome/browser/chrome_content_browser_client.h"
 #include "chrome/browser/metrics/chrome_feature_list_creator.h"
 #include "chrome/common/chrome_constants.h"
@@ -185,7 +190,7 @@ ChromeTestLauncherDelegate::GetUserDataDirectoryCommandLineSwitch() {
 // the GetAppContainerId to add a test-specific suffix to avoid hitting a race
 // condition in CreateAppContainerProfile.
 class BrowserTestChromeContentBrowserClient
-    : public ChromeContentBrowserClient {
+    : public AdblockChromeContentBrowserClient {
  public:
   bool CreateThreadPool(std::string_view name) override {
     base::test::TaskEnvironment::CreateThreadPool();
diff --git a/chrome/test/base/in_process_browser_test.cc b/chrome/test/base/in_process_browser_test.cc
index ccd42caefb..3decb8e851 100644
--- a/chrome/test/base/in_process_browser_test.cc
+++ b/chrome/test/base/in_process_browser_test.cc
@@ -2,6 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
+
 #include "chrome/test/base/in_process_browser_test.h"
 
 #include <map>
@@ -173,6 +177,10 @@
 #include "content/public/test/network_connection_change_simulator.h"
 #endif
 
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+
 namespace {
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -760,8 +768,22 @@ void InProcessBrowserTest::CreatedBrowserMainParts(
 
 void InProcessBrowserTest::SelectFirstBrowser() {
   const BrowserList* browser_list = BrowserList::GetInstance();
-  if (!browser_list->empty())
+  if (!browser_list->empty()) {
     browser_ = browser_list->get(0);
+    // Adding an allowing filter that overrides and disables all blocking
+    // filters in order to avoid unwanted interactions with simulated network
+    // loads. This custom filter is removed for tests that specifically verify
+    // ad-filtering.
+    auto* adblock_configuration =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(
+            browser_->profile()->GetOriginalProfile())
+            ->GetFilteringConfiguration(
+                adblock::kAdblockFilteringConfigurationName);
+    if (adblock_configuration) {
+      adblock_configuration->AddCustomFilter(
+          adblock::kAllowlistEverythingFilter);
+    }
+  }
 }
 
 void InProcessBrowserTest::RecordPropertyFromMap(
-- 
2.49.0

